{"pages":[{"title":"About","text":"안녕하세요 현재 Skelter Labs에서 Software engineer로 일하고있는 이원재라고 합니다. 이 블로그에는 단순한 지식의 나열이 아닌, 실제 실무를 하면서 제가 경험한 것들, 어떤 기술이나 프레임워크를 사용할때 들었던 생각들을 쌓아 나가며 여러사람과 이 경험들을 공유하려고 합니다. Contact medldnjswo19@gmail.com","link":"/about/index.html"}],"posts":[{"title":"어쩌다보니 Opensource Contributor가 되었습니다?","text":"일단 내 소개를 하자면 Skelter Labs라는 곳에서 인턴생활을 하고있는 평범한 대학교 3학년이다. “평범하다”라는 수식어를 붙인 이유는 지금부터 얘기할 것들이 누구나 오픈소스라는걸 생각할때 드는 느낌들이고, 누구나 할 수 있고, 그리 어려운일이 아니라는 점을 강조하기 위해서이다. 나는 프로그래밍이라는 분야가 세상에 존재하는지도 모르는체 그저 물리안하는 학과로 가기위해 컴퓨터 공학과에 오게되었고 정말 운이 좋게도 프로그래밍이라는 분야에 재미를 느껴 이것저것 해오고있다. 사실 1학년때도 그냥 학교수업만 들었으며 2학년이 시작되고부터 이런저런 커뮤니티를 돌아다니며 넓은 세상을 보려고 했던 것 같다. 생활코딩 오프라인 강의, 네이버 오픈소스 세미나, 9XD 등등의 모임을 다니면서 나와 같이 성장하고 싶은 사람들이 어떤 경험을 쌓으면서 실력을 키워왔는지 들으러 다녔다. 그런 곳에서 공통적으로 비슷하게 하는 말 중 하나는 오픈소스에 컨트리뷰트 하라 =는 말이었다. 소스코드에서 필요한 기능을 추가하거나 에러를 찾아서 커밋하거나 적어도 README를 번역하는 그런 활동말이다! 그런데 나는 README를 번역하기에는 영어실력이 부족했고 도대체 이렇게 많은 오픈소스에서 어떤 소스를 골라서 컨트리뷰트를 해야할지 갈피를 못잡았다. 일단 애초에 그렇게 덩치가 큰 소스에서 어떻게 필요한 기능 또는 에러를 찾을지 감이 잡히지 않았다. 세상엔 크고 아름다운(?) 코드들이 많았고, 내 눈은 매우매우 높아서 작은 프로젝트는 보이지도 않았다. 그래서 에라 모르겠다 일단 학교나 잘 다니자 라는 생각으로 뭔가 이런 활동을 하는걸 살짝 놓았다. 그러나 마음속으로는 미련이 남았던지 여러곳에서 이리저리 정보를 찾아다녔다. 그러던중 Rellat이라는 곳에서 프로그래밍에 대한 생각들과 오픈소스에 대한 글을 봤다. 내가 느끼기에 Rellat에서 말하는 것들의 중심 생각은 프로그래밍을 배울때는 이런 과정을 거쳐야 한다는 것이었다. 잘 쓰여진 간단하고 작은 코드를 읽어보고 분석한다. 분석한 코드를 다른 프로그래밍 언어로 포팅하면서 제대로 이해했는지 확인한다. 코드의 성능 및 구조를 개선한다. 이러한 작지만 꾸준한 일들을 많이 한다. 그 일들을 조합하여 내가 만들고 싶은 프로그램을 만든다. 이 과정을 들으면서 내가 시도했던 것들의 문제점을 발견했다. 나는 코드를 읽고 분석도 못하면서 개선부터 하려고들었다. 작지만 꾸준한일보다 크고 일회성인 일을 하려는 도둑놈 심보가 있었다. 내가 만들고 싶은 프로그램을 만들지도 않았다. Rellat에서는 저러한 과정을 장려하고 많은사람에게 좋은 프로그래밍 습관을 말해주기 위해 멘토링을 하고있었고, 나는 당연히 이 멘토링에 참여했다. 멘토링을 하면서 했던 일들은 저기있는것과 동일하다. 내가 이해할 수 있을만큼의 작은 소스코드를 찾고, 그 소스코드를 분석 및 개선하고, 다른 일들과 조합하는 것들을 하면서, 그 과정을 전부 기록하는 것이었다. 이러한 과정을 하면서 나는 점점 큰 프로그램의 소스코드를 분석하고 구조를 파악하는 능력이 자연스럽게 생겼고, 그것을 내가 하려는 작업에 적용하는 일 까지는 할 수 있게되었다. 음 그런데 뭔가 기회가 안보였다. 아무리 작은 프로그램들을 가져다 써도 에러나 개선점은 모르겠는걸? 나는 단지 내가 필요한 부분만을 분석해서 내 일에 적용할 뿐인데 어떻게 오픈소스에 컨트리뷰트 해야하는거지? 이런 생각이 들었지만 일단은 작은 일들을 계속 해나가기 시작하다가 우연한 기회로 스타트업 면접을 보게되었고 회사에서 일할 기회가 생겼다. 회사에 들어가서 일하다보니 지금까지 하던 작업들과 다르지 않았다. 물론 처음부터 만들어야 하는 것들도 있었지만 기본적으로는 어떤 기능이 필요하면 그 기능을 하는 라이브러리를 먼저 비교분석하고 제일 적절한 것을 가져다 쓰며 튜닝한다. 지금까지 해왔던 “필요한 작은 프로그램을 찾고, 그것을 분석해서 내가 하는일에 적용한다”와 정확히 일치하는 일이었고 기능을 하나하나 구축하기 시작했다. 기능을 하나하나 구현하던 중, 정말 진짜 진심으로 내가 짠 모듈의 로직에는 아무런 문제가 없었고, 단일 모듈만으로 테스트 했을 때는 잘 돌아가던 코드가 다른 모듈들과 같이 돌리면 돌아가지 않는 문제가 있었다. 디버깅 해보니 원래 회사에서 쓰던 어떤 플랫폼 같은 소스를 확장해서 개발 중 이었는데 거기 있던 default 모듈중 하나에 문제가 있었던것이다! 자바스크립트 context가 맞지 않아서 어떤 프로퍼티가 불려지지 않았고, 그 모듈을 로딩하던 중 에러가 발생해버려서 내 모듈이 불리지 않았었다. 따라서 나는 그 부분을 수정하고 PR을 올렸는데 Merge가 덜컥 되어버렸다! 갑자기 contributor가 되었다! 이렇게 컨트리뷰트를 하고 나서 느낀점은 작은 소스들을 분석하면서 소스코드 분석력을 키우자 아무리 작은 부분을 고쳐야 하더라고 전체적인 구조 분석이 필요하다 아무 상관도 없는 재미없는 코드분석 보다는 지금 하는일에 사용중인 라이브러리의 오류나 개선점을 찾는게 낫겠다. 라이브러리 쓰다보면 자연스럽게 코드를 뜯어보게 된다. 토이프로젝트를 많이 하자! 오픈소스도 사람이 만든 것이라 여러사람의 도움을 필요로 하고 환영한다. 앞으로도 기회가 생기면 다른 사람도 나와 같은 라이브러리를 사용하면서 같은 삽질을 안할 수 있게 하기위해서 계속해서 컨트리뷰트 할 생각이다.","link":"/2018/05/30/am-i-opensource-contributor/"},{"title":"Git unstaged changes, untracked file 제거하기","text":"개발을 하다보면 현재 작업한 파일 이외에 필요 없는 파일들이 생성 될 때가 있다. 보통 app build를 할때 생성되는 파일이 대표적이다. 또한 내가 수정한 파일들 중 test로 수정을 한 다음 다시 원래대로 돌려놓고 싶을 때가 있다. 물론 항상 제외해야하는 파일들은 .gitignore에 잘 등록을 해둬야겠지만 예외 상황에는 이렇게 하면 된다. 한번 staged, unstaged, untracked 상황을 보며 얘기해보자 Staged change Staged change은 보통 이미 git에서 tracking이 되고 있으며 change가 있는 파일중 git add (filename or directory name) 를 통해 stagging 상태에 있는 파일을 의미한다. 이 상태에서 commit 하면 stagging 된 파일들만 해당 커밋에 추가된다. Unstaged change unstaged change은 보통 이미 git에서 tracking이 되고 있으며 change가 있는 파일이 여기에 해당한다. 이 파일을 테스트로 수정했거나, 이전에 tracking 되던 파일인데 build를 하니 내용이 바뀌었다던가 하면 아래와 같은 코드로 원래대로 돌릴 수 있다. 1git checkout (filename or directory name) 물론 build를 하니 내용이 바뀌는 파일이 있을때는 그 원인을 정확히 파악하고 수정해야한다. build를 할때마다 바뀔수는 없으니 ㅠㅠ 필자는 iOS build를 할때 protobuf 라이브러리가 계속해서 protobuf -&gt; Protobuf로 변경되는 이슈가 있었는데, 왜그런지 보니 protobuf 버전이 낮아서였고 pods 폴더를 제거하고 protobuf 버전을 높여서 다시 pod install 하니 해결되었다. Untracked file untracked file은 새로 추가된 파일이 이 상태로 뜨게된다. build 폴더를 ignore 안해놨다던가, 실수로 이미지파일이 추가되었다던가, 하는 등등의 이유로 뜨게된다. 이때는 1git clean -fd 이 명령어로 해결할 수 있다. 주의해야 할 점위의 명령어들로 change를 제거했을 경우 되돌릴 방법이 없다. 또한 항상 왜 필요없는 파일이 생기는지 파악하고 해결하는 것도 좋은 공부가된다. 추가로!staged change를 unstaged 또는 untracked로 되돌리려면? 1git reset","link":"/2019/11/06/git-delete-unstaged-untracked-file/"},{"title":"Flutter plugin 개발하기 - part4 플러터 플러그인 pub.dev 에 배포하기","text":"이야기를 하기에 앞서, 이 글은 네가지 파트로 나뉘어져 있습니다. 각 글을 나눈 기준은 제가 항상 Flutter로 개발하면서 작업을 나누는 단위입니다. 각 단위 내에서도 더 작게 쪼개지지만 플랫폼 관련 기능을 구현할 때는 Flutter -&gt; iOS -&gt; Android 순서로 작업합니다. (Android보다 iOS쪽이 제약이 많기 때문에 기능 확인차 이렇게 하고있습니다.) Flutter plugin 만들기 part1 - Create Flutter Plugin Flutter plugin 만들기 part2 - iOS 환경 세팅 (Swift) 및 개발하기 Flutter plugin 만들기 part3 - Android 환경 세팅 및 개발하기 Flutter Plugin 만들기 part4 - 플러그인 배포하기 Flutter plugin의 배포는 어렵지 않다. 2단계면 끝난다. 하지만 그 전에 작성해야 할 것들이 있다. pubspec.yaml이 파일에서 최소 author, description를 입력해야 한다. 필자는 조금 더 추가적인 정보를 입력 해 두었다. 12345678name: wifi_connectordescription: Flutter plug-in for connecting to wifi.version: 1.0.0author: wonjerry &lt;dldnjswo19@gmail.com&gt;homepage: https://wonjerry.github.io/repository: https://github.com/wonjerry/flutter_wifi_connector... pub.dev의 플러그인 Scoring system아래의 것들을 반드시 입력하지 않아도 publish 할 수 있지만 pub.dev에서는 어떤 플러그인이 제대로된 플러그인인지, 또 그걸 사용하는 개발자들이 사용하기 용이한지 몇가지 항목을 체크한다. README의 작성 여부 이 플러그인에 대한 설명이 잘 작성되어 있어야 한다. CHANGELOG의 작성 여부 각 버전 별 변경사항이 작성되어있는 파일이 있는지 체크한다. pubspec.yaml 파일에 버전 및 description 작성 여부 description이 충분히 길지 않으면 경고를 주며, 짧으면 점수가 깎인다. 버전이 0.0.1 버전 즉 pre-v0.1 release. 이면 점수가 깎인다. 기본 기능을 다 갖춘 플러그인이라면 1.0.0으로 버전을 세팅 후 올리도록 하자. 내부 파일의 formatting 여부 위의 것들 이외의 여러 기준이 있지만, 보통 위의 것들만 충족한다면 플러그인의 점수가 높게 측정되며 사용자들이 pub.dev에서 검색했을 때 신뢰도가 올라간다! 플러그인 배포하기 flutter packages pub publish —dry-run을 통해 먼저 해당 플러그인을 배포하는데에 문제가 없는지 확인한다. flutter packages pub publish를 입력하여 배포하면 끝!! publish를 하게되면 위와같이 구글 oath를 통해 인증을 해야하는데 저 링크를 따라 들어가서 내 구글 아이디로 로그인 하고 나면 publish가 완료된다! 1~2일 후에 publish되었다는 메일이 오고, 실제 pub.dev에서 내 플러그인이 올라가있는지 확인할 수 있다! publish 완료 메일123456789Dear package maintainer,dldnjswo19@gmail.com has published a new version (1.0.0) of the wifi_connectorpackage to the Dart package site (pub.dev).For details, go to https://pub.dev/packages/wifi_connector/versions/1.0.0If you have any concerns about this package, file an issue athttps://github.com/dart-lang/pub","link":"/2019/11/25/make-flutter-plugin-part4/"},{"title":"ESLint, TSLint, Typescript-ESLint 무엇을 선택해야는가","text":"Introduce 🛫최근에 Flutter로 한동안 개발하다가 다시 react + typescript로 웹개발을 시작하게 되었다. React를 하지 않는동안 생각보다 많은 변화가 있었다. 나는 개발을 시작하기 전에 개발에만 집중 할 수 있도록 미리 tool들과 환경세팅을 하는 것을 중요하게 생각하고, linter 설정을 잘 해두는 것이 개발효율을 높여준다고 생각하기 때문에 새로운 프로젝트를 할때 신경을 쓰려고 한다. 그런데 다시 돌아오고나니 ESLint, TSLint 심지어 Typescript - ESLint가 있다. 여러 블로그를 참고해서 세팅은 했는데.. 패키지는 왜이렇게 많이 설치해야하며 각각 무슨일을 하는지도 모른체 설치했다. 도대체 뭘 골라서 설치해야하지?! ESLint? 🤔ESLint는 javascript code를 위한 linter이다. 다른 Linter들도 있지만, ESLint는 여러 styke애 대해 configure 하기가 쉽고, 다른 플러그인을 붙이기도 편하며, 나만의 eslint rule을 sharable configs로 만들어어서 npm을 통해 공유할 수 있어 현재 많이 쓰이고 있는 추세이다. 간단하게 ESLint의 동작 방식에 대해 알아보자. Javascript code를 parser를 통해서 AST로 변환을 하게 된다. AST는 프로그래밍 언어 문법에 따라 소스 코드 구조를 표시하는 정보를 담은 Tree다. 123function printTips() { tips.forEach((tip, i) =&gt; console.log(`Tip ${i}:` + tip));} 123456789101112131415161718192021222324252627282930313233343536373839404142{ \"type\": \"Program\", \"body\": [ { \"type\": \"FunctionDeclaration\", \"id\": { \"type\": \"Identifier\", \"name\": \"printTips\", \"range\": [ 9, 18 ], \"loc\": { \"start\": { \"line\": 1, \"column\": 9 }, \"end\": { \"line\": 1, \"column\": 18 } } }, \"generator\": false, \"expression\": false, \"async\": false, \"params\": [], \"body\": { \"type\": \"BlockStatement\", \"body\": [ { \"type\": \"ExpressionStatement\", \"expression\": { \"type\": \"CallExpression\", \"callee\": { \"type\": \"MemberExpression\", \"object\": { \"type\": \"Identifier\", \"name\": \"tips\", \"range\": [… 첫번째 블록과 같은 코드가 있을 때, 이걸 두번째 블록과 같은 메타 데이터를 담은 tree형태의 데이터 구조로 변경시켜 준다. ESLint는 기본적으로 Espree 라는 parser를 사용하며, babel-eslint 또는 Esprima와 같은 parser로 변경할 수 있다. AST explorer 여기서 직접 AST가 만들어 지는 것을 확인할 수 있다. 위와 같은 AST 데이터는 lint 관련 plugin들에서 쓰이며, 세팅된 configure에 따라 warning을 주거나, fix를 해준다. Typescript? 🤔Typescript-ESLint에서 ESLint는 알겠는데 typescript는 무엇인가? Typescript는 Javascript라는 language의 상위 레이어에서 추가적인 문법을 가지고 Javascript code에 대한 정적 분석을 하는 parser이다. Typescript의 동작 방식 Typescript를 parser라고 하는 점에서 눈치 챘듯, ESLint 내부에 있는 parser와 같이 Typescript도 source code를 AST로 변환한다. AST 데이터는 typescript의 다른 compiler 에서 쓰이며 error를 뱉거나 refactor를 쉽게 해준다. 그렇다면, Typescript-ESLint는 왜 만들었는가?위에서 설명했듯, typescript와 eslint는 둘 다 source code를 AST로 변환한다. 하지만 AST라는 구조만 동일한것이지 디테일하게 보면 각각이 다른 AST를 사용한다고 볼 수 있다. 즉 Typescript-ESLint는 typescript와 eslint의 다른 AST format을 parsing하여 원래 javascript linter인 eslint를 typescript에서도 쓸 수 있게 하기 위한 프로젝트 이다. (이전에 잘 만들어 두었던 것을 재사용할수 있겠죠?!) TSLint는 왜 deprecated…?TSLint는 ESLint와 같은 레벨의 프로젝트로써 ESLint가 javascript code를 lint check 하는 것 처럼 typescript에 특화되어서 typescript code만를 lint하는 linter이다. TSLint는 typescript에 특화되어있다보니 eslint가 javascript ecosystem에서 잘 구축해놓은 system과 code들을 재사용하지 못하고 독자적으로 따로 구현을 해야하는 이슈가 존재했다 따라서 TSLint는 결국에 deprecated 되었고 eslint 에서는 tslint를 eslint로 migration하는 툴을 제공하고 있다. ESLint를 적용하기 전에…그러면 ESLint환경에서 typescript-eslint만 설치하면 되느냐? 그것도 아니다. typescript-eslint하나만 존재하는 것이 아니라 @typescript-eslint/eslint-plugin, @typescript-eslint/parser등 관련 플러그인을 깔아야 한다. 왜 이렇게 verbose 하게 여러 패키지를 import 하도록 구성해놨을까? 이전에 설명했던 내용으로 돌아가면 Typescript가 생성하는 AST는 ESLint가 생성하는 AST와 다르다. 따라서 Typescript의 AST는 오랜시간동안 eslint 사용자들이 작성한 수많은 rule과 맞지 않는 다는 것을 의미한다. 하지만 ESLint는 여러 플러그인을 붙여서 lint configuration을 할 수 있도록 해놓았다. parser도 마찬가지로 javascript를 사용할때는 espree라는 기본 parser를 사용하면 되지만 typescript의 경우에는 @typescript-eslint/parser를 따로 설치 및 설정 해 두어야 한다. 이와같이 ESLint 라는 기본 틀에 typescript 관련 플러그인을 추가 구성하는 방식으로 typescript를 지원하고 있으므로 @typescript-eslint/eslint-plugin, @typescript-eslint/parser등을 각각 설치 해 주어야 하는 것이다. ESLint + Typescript + vscode 환경을 세팅해보자! ESLint 관련 package를 설치한다. 1yarn add -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-react standard .eslintrc.yaml에 eslint 관련 초기 세팅 및 rule 세팅을 해준다. vscode에 eslint 확장자를 설치한다. vscode settings에서 Format on save 검색하여 켜준다. Format이 적용되지 않은 파일에서 save를 해보자 Before After ESLint sharable config 생성 및 배포 🚀우리는 프로젝트를 생성할 때 마다 eslint를 적용하기 위해 수많은 패키지를 설치 한다 ㅠㅠ.. 이 과정을 한번에 할수는 없을까? eslint는 관련 세팅을 패키지화 해서 npm에 upload 할 수 있다. 이것을 sharable config라고 하며 만약 현재의 lint 설정 과정을 패키지화 해놓는다면, 프로젝트를 만들 때 마다 같은일을 반복하지 않을 수 있어 개발 효율을 높일 수 있다. Publish to npm 프로젝트 이름을 eslint-config-[설정 이름] 으로 세팅한다. eslint-config-wonjerry 폴더 생성 yarn init을 통해 package.json을 생성한다. package.json에서 peerDependency에 eslint config가 사용하는 peer dependency를 명시 해 준다. Index.js에 원하는 eslint rule 들을 설정해준다. yarn publish 명령어를 통해 publish 한다.version, npm username, npm email, npm password 등을 입력하고 publish 한다. (당연히 npm 회원 가입은 되어있어야겠죠?) Install in project eslint-config를 사용할 프로젝트에서는 npm을 통해 해당 config를 install 한다. 1yarn add -D eslint-config-wonjerry eslintrc.yaml 파일을 생성하고 eslint-config-wonjerry를 extends 한다고 적어준다. eslint . —ext .ts —ext .tsx &amp;&amp; tsc 명령어로 확인해서 잘나오면 성공!! 만약 lint 관련 error가 뜬다면 잘 수정해주면 된다. 12$ eslint . --ext .ts --ext .tsx &amp;&amp; tsc✨ Done in 3.71s. Conclusion 🛬이렇게 eslint를 편하게 쓰기 위해 eslint sharable config를 만드는 것 까지 완료하였다. eslint sharable config를 잘 설정해 둔다면 개인 프로젝트 또는 회사의 프로젝트에서 편하게 lint setting을 할 수 있어 개발 효율을 높였다.","link":"/2020/04/01/eslint/"},{"title":"Flutter error - The method ‘inheritFromWidgetOfExactType’ was called on null 에 대한 고찰","text":"Introduce 🛫필자는 현재 회사에서 Flutter로 앱 개발을 하고있으며 Sentry라는 error tracking tool을 사용하여 실제 배포된 앱에서 발생하는 error을 tracking 하고있다. QA에 들어가니 sentry에서 알수없는 error report가 오기 시작했다. Stack trace를 살펴보면 widget tree에서 AppState라는 ChangeNotifier를 찾는 inheritFromWidgetOfExactType이라는 메소드가 null에서 call 되었다고 한다. 뭔지 모르겠지만 코드를 한번 보자. 1234567@overridevoid initState() { super.initState(); SomeAsyncApiRequest().request().then((response) { Provider.of&lt;AppState&gt;(context).setData(response.data); });} [비동기 요청을 하는 부분] 123456static T of&lt;T&gt;(BuildContext context, {bool listen = true}) { ... context.inheritFromWidgetOfExactType(type) as _Provider&lt;T&gt; ... return provider.value;} [widget tree에서 AppState를 찾는 부분] 위의 코드는 다음과 같은 과정을 거친다. Stateful Widget이 init 될 때 initState 메소드가 불린다. 비동기 API call을 한다. 응답이 오면 context를 통해 inherited widget인 AppState를 widget tree에서 찾는다. 응답으로 온 데이터를 set 한다. 이 코드를 짤때는 흐름상 아무런 문제가 될 부분이 없었고, 테스트도 잘되었다. 하지만 배포를 하고 실 사용자가 사용할때는 꽤나 자주 저 Error가 발생했다. 원인을 파악해 보니 다음과 같다. 🔦 stateful widget이 생성되면서 비동기 요정을 하고 context를 통해 appState를 widget tree에서 불러오려고 했다. 사용자가 비동기 함수가 끝나기 전에 back button을 눌러서 뒤로 가버린다. widget이 unmount되어서 context가 사라졌고 글 제목과 같은 에러가 났다. 사실 여기까지만 파악해도 원인은 알고있고 해결할 수 있었다. AppState를 widget tree에서 context를 통해 찾을때 비동기 함수 바깥에서 call 하여 찾으면 됐고, 찾은 AppState를 비동기 함수내에서 사용하면 context를 안쓰기때문에 문제가 없었다. 1234567@overridevoid initState() { super.initState(); SomeAsyncApiRequest().request().then((response) { AppState.of(context).setData(response.data); });} 이렇게 쓰던걸 12345678@overridevoid initState() { super.initState(); final appState = AppState.of(context); SomeAsyncApiRequest().request().then((response) { appState.setData(response.data); });} 이런식으로! 흠 뭔가 찝찝한데… 🤔하지만 좀 더 깊은 부분이 궁금했다. 이 현상의 원인은 뭘까? context는 뭐고 widget tree는 무엇인가? 더 깊은 내용을 파고들어보자. Stateless Widget과 Widget tree, Element tree 🎄 이 글을 보는 사람들은 Stateless Widget에 대한 기본 지식이 있다고 생각한다. 따라서 Stateless에 대한 기본적인 내용은 생략한다. [ MyButton(Stateless Widget)의 코드와 UI 이미지 ] 코드를 보는게 쉬우니 먼저 코드 예시를 보자. MyButton이라는 Stateless Widget을 만들고 MyHomePage라는 StatefulWidget 안에 배치하였다. 이 widget들이 배치되어있는 형태를 잘 생각해보면 tree 형태이다. Stateless widget은 어떻게 tree 형태를 이룰까? 🤔 위젯들은 그림과 같은 형태로 Widget tree를 이루며 Center의 자식으로 Column, Column의 자식으로 MyButton이 tree 형태를 이룬다. 하지만 사실 Widget은 설계도에 불가하다. 이 설계도를 바탕으로 실제로 화면에 보여지는 것은 따로있다. 바로 Element 이다. Center widget, column은 엄밀히 말하면 stateless widget은 아니다. 하지만 이 글에 주제는 stateless이므로 그부분의 설명은 생략하고 widget tree, element tree에 마운트되는 단계를 살펴보려 한다. Center widget은 생성된 다음 element를 생성하며 그 element는 element tree에 mount 된다. 그 다음 자신의 child widget을 생성하고 widget tree에 마운트한다. Column widget도 Center widget과 같은 과정을 거친다. MyButton widget은 생성된 다음 element 인스턴스를 생성한다. Stateless Widget의 내부 코드를 보면 createElement라는 메소드가 존재하며, 위젯 생성시 내부적으로 call 된다. 생성된 element는 element tree에 mount되며, widget class를 reference로 들고있다. (위의 코드를 보면 StatelessElement를 생성할 때 StatelessWidget의 instance를 넣어주는 것을 볼 수 있다.) 이런식으로 설계도인 Widget들에 의해 생성된 element tree가 실제 화면상에 보여지며 user와 interaction 한다. element class의 코드를 조금 더 파보자. [Flutter framework 내부의 StatelessElement class 코드] element class의 멤버 변수인 widget은 앞서 생성자에 넣어줬던 stateless widget instance이다. element도 build 메소드를 가지고 있는데, element가 element tree에 마운트될 때 call 된다. 자세히보면 widget의 build 메소드에 element instance를 넣어주고있는데, widget의 build 메소드를 보면 BuildContext라는 타입으로 받고있다. 즉, Context는 결국 Element인 것이다. update method도 자세히 살펴보면 재미있는것이, newWidget을 인자값으로 받고있는데 type이 StatelessWidget이다. 즉 StatelessWidget은 rebuild 될때마다 재생성되지만 element는 재생성 되지 않으며 단지 업데이트를 할 뿐이다. 더 나아가서 Flutter가 내부적으로 효율적인 rebuild를 위해 고려한 부분을 볼 수있다. 마치 react의 virtual dom 같은 역할을 한다. Stateful Widget 과 Widget tree, Element tree 🎄 이 글을 보는 사람들은 Stateful Widget에 대한 기본 지식이 있다고 생각한다. 따라서 Stateful Widget에 대한 기본적인 내용은 생략한다. 이번엔 앞의 코드를 조금 더 발전시켜서 각 버튼을 누르면 버튼 색이 🔵 -&gt; 🔴 으로 변화하는 코드를 만들어보자. 예시를 보자. MyButton이라는 Stateful Widget을 만들고 MyHomePage라는 StatefulWidget 안에 배치하였다. 그리고 MyButton은 _buttonColor라는 state를 들고있으며 버튼을누르면 setState를 통해 _buttonColor state를 변경하고 해당 위젯을 rebuild 한다. Stateful widget은 어떻게 tree 형태를 이룰까? 🤔 MyButtonWidget이 먼저 생성된다. 그리고 StatefulElement가 생성된 후 element tree에 mount 된다. stateless와 동일하게 StatefulElement가 Widget의 인스턴스를 들고있다. MyButtonWidget이 State 인스턴스를 생성한다. MyButton widget의 child들이 순차적으로 생성되며 widget tree, element tree에 마운트 된다 Stateless와 다른점은 State object가 존재하며 element가 widget, state 의 인스턴스를 들고있다는 점이다. 그럼 StatefulElement에서는 어떤일이 일어날까? 🤔 다른 부분은 생략하고 build 메소드를 보자. state의 build 메소드가 불리고 있으며, context를 StatefulElement의 인스턴스로 주고있다! 결국 StatefulWidget의 context도 element이다! 그렇다면 state가 바뀔땐 어떤 과정이 발생할까? 🤔 setState가 call 되면서 state 인스턴스 내부의 _buttonColor를 blue -&gt; red로 변경한다. Stateful element에 dirty check를 한다. 다음 frame에 dirty 표시된 elemet에 의해 MyButtonWidget이 다시 생성된다. 이때 MyButtonWidget element의 update 메소드가 call되며 새로운 instance를 받는다. 이때 dirty 값이 true로 바뀌며 rebuild를 진행한다. 또한 newWidget을 인자값으로 받고있는데 type이 StatefulWidget이다. 즉 StatefulWidget은 rebuild 되는 상황마다 재생성되지만 element는 재생성 되지 않으며 단지 업데이트를 할 뿐이다. 하위의 자식 StatelessWidget들은 rebuild시 모두 다시 생성된다. 이때 바뀐 _buttonColor에 대해 FlatButton Widget이 🔵 -&gt; 🔴 로 변경된다. Stateless Element이 referece 하고있는 FlatButton이라는 위젯의 타입이 이전과 같으므로 element는 다시 생성되진 않고, 다만 widget의 rebuild 메소드를 call 한다. 모든 child에 대해서도 순차적으로 rebuild 과정이 진행된다. 정리해보면 Stateful widget의 context는 stateful element를 의미하며, 이말은 결국 context는 element와 생명주기를 같이한다는 말이다. 즉 element tree에 마운트 되어있지 않으면 context가 없는것이고, 마운트 되어있으면 context가 존재하는 것이다. Inherited Widget 과 Widget tree, Element tree 🎄 이 글을 보는 사람들은 Inherited Widget에 대한 기본 지식이 있다고 생각한다. 하지만 글의 흐름을 위해서 간단히 설명하자 Inherited Widget은 자식들이 Inherited Widget에 대한 직접적인 reference가 없어도 접근 가능한 위젯이다. 어떤 자식이 Inherited Widget을 consume 하기만 해도 자동으로 listener로 등록되며 Inherited Widget이 rebuild 될때마다 listenter로 등록된 자식위젯도 notify를 받고 rebuild 된다. 이 글의 처음에서 봤듯 AppState는 ChangeNotifierProvider내부에 존재하며, Provider는 inherited widget의 일종이다. 잠깐! Inherited Widget을 설명하기 전에 먼저 Provider를 간단히 설명하자. Provider? 🤔Provider는 기본적으로 어떤 것(Stream, Future, Object, ChangeNotifier..)을 자식들에게 제공하는 역할을 한다. Provider의 class diagram을 잠시 살펴보자. AppState는 ChangeNotifier이고, ChangeNotifierProvider가 provide하고있다. ChangeNotifierProvider는 ListenableProvider를 상속하고있다. ListenableProvider는 InheritedProvider를 build, 즉 생성한다. InheritedProvider는 InheritedWidget을 상속받고있다. 결국 ChangeNotifierProvider는 일종의 InheritedWIdget이다. 자 다시 Inherited Widget으로 돌아오자 👋12345class AppState extends ChangeNotifier { ... static AppState of(BuildContext context) =&gt; Provider.of(context)} [AppState class] 123456789101112131415// AppState를 Provide 하는 코드@overrideWidget build(BuildContext context) { final theme = defaultTheme(context); final appTheme = defaultAppTheme(context); return MultiProvider( providers: &lt;SingleChildCloneableWidget&gt;[ Provider.value( value: AppTheme( light: appTheme, ), ), ChangeNotifierProvider(builder: (context) =&gt; AppState()), ], ... [AppState를 자식 위젯들에게 provide 하는 코드] ChangeNotifierProvider에서 AppState를 자식 Widget들에게 provide 한다. 자식 Widget들은 Provider의 of 메소드를 통해 AppState를 Provide 하고있는 ChangeNotifierProvider(Inherited Widget)를 Element tree에서 찾는다 여기서 Element tree인 이유는 앞서 설명했듯 context가 element를 의미하며, Inherited widget도 결국 InheritedElement를 생성하여 element tree에 마운트 되기 때문이다. 1234567891011121314static T of&lt;T&gt;(BuildContext context, {bool listen = true}) { // this is required to get generic Type final type = _typeOf&lt;_Provider&lt;T&gt;&gt;(); final provider = listen ? context.inheritFromWidgetOfExactType(type) as _Provider&lt;T&gt; : context.ancestorInheritedElementForWidgetOfExactType(type)?.widget as _Provider&lt;T&gt;; if (provider == null) { throw ProviderNotFoundError(T, context.widget.runtimeType); } return provider.value; } [Provider library의 ‘of’ method 내부코드] Provider의 ‘of’ 메소드의 내부를 보면 inheritFromWidgetOfExactType이라는 메소드를 통해 ChangeNotifierProvider(Inherited Widget)를 찾는다. 찾은 provider의 value 즉 ChangeNotifier(AppState)를 return한다. ⚡ 정리하자면 context로 widget tree를 탐색해서 AppState를 찾는것이 아니다. Context는 Element이고 element tree를 탐색해서 AppState를 찾아냈다. ⚡ Context앞서 설명한 내용과 같이 context는 element tree에 마운트되어있는 element이다. 잠시 State Class의 내부 코드를 보자. StatefulElement 인스턴스를 _element라는 변수로 들고있다. context라는 getter가 존재하며, _element를 return한다. 앞서 같이 봤던 예제를 다시한번 보자. 1234567@overridevoid initState() { super.initState(); SomeAsyncApiRequest().request().then((response) { AppState.of(context).setData(response.data); });} 비동기 함수가 끝날때 getter인 context를 call 해서 AppState의 of 메소드의 인자값으로 넣어주고있다. context는 element이다. element가 unmount 상태라면 element == null 이다. of 메소드 내부에서는 context.inheritFromWidgetOfExactType() 이라는 메소드가 call 된다. context가 null이기 때문에 inheritFromWidgetOfExactType’ was called on null 에러가 발생한다!! 😡 만일 getter를 통해 element를 사용하는 것이 아니라 element를 미리 저장해두고 위와같은 동작을 한다고 하더라도 Could not find the correct Provider&lt;AppState&gt; above this Widget 라는 에러가 발생한다. 즉 unmounted인 element(context)로 접근하려 하면 안된다!!! ⚡ 따라서 context를 사용해서 element tree상의 inherited element을 찾을때는 element가 mounted인 상태임이 보장되어야 한다. ⚡ Conclusion 🛬사실 세 종류의 위젯들을 공부하면서 widget tree와 element widget의 존재를 알게 되었고, context를 공부하면서 element tree에 mount 된 Inherited Element를 찾는거다라는것을 알아냈었지 inheritFromWidgetOfExactType이 왜 발생하는지, 왜 에러가 발생하는 당시에는 몰랐다. 일을 하면서 회사 사수분이 비동기처리할 때 context 사용 타이밍 이슈가 있어서 저런 에러가 난다 라는 것을 찾아내시고, 나는 그것과 위에 말한 지식들을 조합 해보니 이 글과 같은 결론이 났다. 이렇게 깊이 파고들고나니 좀더 Flutter에 대한 이해도가 깊어졌으며 더 재미있게 그리고 잘 개발할 수 있겠다는 생각이 들었다.","link":"/2020/01/02/inheritFromWidgetOfExactType/"},{"title":"오픈소스를 분석하며 게임들을 만들어 본 후 느낀점","text":"서론이전에 오픈소스로 게임만드는 과정을 글로 쓴것들이 있었다. 그것들을 진행해 보면서 공통적으로 느꼈던점, 배운점을 회고해보고 앞으로 내가 어떤 생각을 가져야 할지 정리해보려고 한다. 글로 쓴 내용은 2개 뿐이지만, 사실 자잘하게 만든 것들도 몇개 더 있었다. 하지만 너무 두서없이 만든 경향이 있고, 내가 전부 만든게 아닌 다른 분과 만든 부분도 있어서 글로 정리하기가 어려웠다 ㅠㅠㅠ 다음부터는 하나 끝나고 나면 꼭 정리하는 시간을 가져야지 ㅠㅠ 왜 게임을 만들기 시작했는가? 나는 2017년 6월쯤에 한창 고민에 빠져있었다. 이제 학교에서 하는 것들은 잘 하는거 같고, 재미도 있다. 그런데 더 잘하려면 뭘해야하는가? 라는 생각을 했고 이리저리 커뮤니티도 많이 다니고, 강연도 들으면서 뭘 해야할까 찾아다녔다. 그리고 마이다스아이티의 해커톤도 다녀와봤는데 학교레벨 정도의 것은 잘하나, 아직 개발을 혼자서 많이 해보지는 않은 느낌이라는 생각이 들었다. 그 시즌에 온라인 멘토링 관련 글을 봤고, 멘토링 가이드 글을 읽어보았다. 멘토링의 내용은 자신이 만들고 싶은 것을 과제로 정하고 그것에 대한 분석을 하고, 관련된 오픈소스를 리서치하고, 그 소스를 개선 및 재조립하여 만들어가면 멘토분들이 도와주는 내용이었다. 그리고 만들고 싶은게 없거나 아직 만들기엔 실력이 부족하다고 느껴지면 작은 게임을 만들어보라는 내용이었다. 사실 맨 처음에는 나름 컴공이고 여러가지 만들어봤다고 생각해서 규모가 약간 크고 아직 배우지 못한 내용인 프로그램을 생각했었다. 그러나 이걸 만드려고 하니 어떻게 돌아가야 할지는 머리속에 그려지지만 디테일하게 어떻게 접근해야할지도 모르겠고 어떤 부분을 공부해 나가야 할지도 모르겠어서 흐지부지 되버리고 말았다. 그래서 차라리 테트리스 게임을 만들어 보자고 생각했다. 왜냐면 이전부터 만들어보고 싶었고, 많은 사람이 많이 만들어본 것이기 때문에 참고할만한 오픈 소스가 많고, 생각해보니 작은 게임조차도 콘솔 이외의 것으로 처음부터 끝까지 만들어본적이 없었기 때문이다. 그리고 그 당시 서버에대한 관심이 있었고, 뷰를 만드려면 html,css,js로 만드는 편이 접근이 쉽다고 생각했고 js로 서버를 만들수 있는 nodejs가 있었기 때문에 자바스크립트 강의를 빠르게 들으면서 게임을 만들기 시작했다. 게임을 만들어가는 공통적인 과정은 무엇인가? 몇가지 작은 게임들을 멘토링 글을 보면서, 나 나름 경험하면서 공통적인 과정이 있었다. 자신이 만들고자 하는 게임과 유사한 게임을 검색하고 ‘내가 이해하기 쉬운 규모의 것을 찾기’ 게임을 검색하면 엄청나게 많은 검색 결과가 나온다. 그리고 그것들을 하나하나 분석하면서 어떤것을 가져올지 분석하는 것은 미친짓이라는 생각이 들었다. 그래서 몇가지 기준을 생각하고 기준과 가장 근접한 소스를 여러개 찾아서 데모를 돌려보는 방식으로 했다. 첫번째로 내가 이해하기 어려운 너무 큰 규모의 것은 배제한다. 두번째로 데모가 있는 것은 우선순위로 둔다. 그래야 실제 돌아가는 게임인지, 기능이 제대로 구현되었는지 알기 쉽다. 세번째로 객체화 모듈화가 잘 되어있는지 네번째로 readme가 잘 적혀있는지. readme가 잘 적혀있고 사진이 있어야 더 눈이가고 이해도 쉬웠다. 나중에 나도 제대로 프로그램을 만들면 이미지와 함께 readme를 잘 적는 습관을 들일것이다. 다른 사람의 소스를 이해하기 위와같이 후보들을 추린다음 그중 하나를 선택해서 메소드 하나하나 테스트해보고 분석하기 시작했다. 다른 사람의 소스를 이해한다는 것이 처음에는 쉽지 않은 일이었다. 하지만 모듈화 객체화가 잘 되어있는 소스코드는 이해하기 수월했다. 메인 개념의 소스를 분석하다 보면 여러 모듈이 쓰이기 때문에 어떤 모듈이 어떤 일을 하는지 이해하지 못해서 분석이 막히는 경우가 있었다. 이 경우에는 사용된 모듈부터 차근 차근 분석하면서 각 모듈이 어떤일을 하는이 파악하고 다시 돌아오면 다시 분석할 수 있었다. 작은 게임들을 분석하다 보니 조금 더 큰 규모의 프로그램도 분석이 가능했다. 그것을 내가 하려는것에 적합한 구조로 리펙토링 하기 아무래도 다른 사람이 만든 게임과 내가 게임을 만드려고 생각해둔 로직과 다른점이 있을 수 밖에 없다. 다른 사람의 코드가 객체화가 덜 되어있다면 객체화를 더 진행시킨다. 다른 사람의 로직이 왜 그렇게 진행시켰는지 로직을 찍어보면서 파악해서 그 이유가 타당한것 같다면 내 로직을 수정하고, 아니라면 내 로직을 적용시킨다. 너무 꼬여이있는 소스는 아닌데, 약간 이상하다 싶은 것은 그럴만한 이유가 있을 수 있다. 개선 시킬 수 있다면 개선시키고 아니라면 그대로 쓴다. 콘솔을 꼭 벗어나기 예전에는 java나 c++을 했었는데 대부분 콘솔로 여러가지를 했었다. 대부분 어떤 이론의 테스트 정도를 돌렸던 수준이었던 것 같다. 그런데 뷰를 붙여보고 나니 왜 클래스별로 역할을 나눠야 하는지, 왜 위임이 필요한지, 왜 객체화나 이벤트화가 필요한지 이해하게 되었다. 로컬에서 온라인으로 만들기 위에서 콘솔에서 벗어나는 개념과 비슷하다. 예전에는 게임을 만들어도 항상 오프라인 1인용을 간단하게 만들었었다. 하지만 온라인으로 만들고 멀티플레이로 만들고 나니 동기화에 대해 더 고민하게 되고 어떻게 하면 서버와 클라이언트간의 데이터 이동 빈도, 데이터의 크기를 줄일지 자연스럽게 고민하게 되고 리서치해서 해결하게 되었다. 게임을 만드는 과정에서 배운것은 무엇인가? 남의 소스 이해하기 다른 사람의 소스를 이해하고, 그 사람 로직의 정보처리 과정을 이해하는것이 쉬워졌다. 아무리 큰 프로그램이라도 두려움 없이 차근차근 분석할 수 있겠다는 생각이 들었다. 리펙토링 경험 이전에는 내 코드를 다시 보고 구조를 개선시키는 일은 해본적이 없었다. 게임을 여러개 만들면서 다른 사람의 소스 구조를 개선시킬 때도 있었고, 내가 만든 코드를 1인용 오프라인 -&gt; 1인용 온라인 -&gt; 다인용 멀티플레이 로 만들어 가면서 자연스럽게 계속 내 코드를 리펙토링 하는 계기가 되었고 내 수준에서는 많은 도움이 되었다고 생각한다. 큰 일을 작은 단위로 만들어서 처리하기 작은 소스를 분석하고 개선하는 것은 이제 수월했다. 큰 소스를 분석하기 시작하면서 규모가 커지고 코드 라인이 많아졌다는 이유만으로 어렵다라고 느껴졌다. 하지만 위에서 말했듯, 소스를 분석하면서 작은 모듈들의 기능을 먼저 이해하고 그것을 바탕으로 큰 메인 로직을 이해하기 시작하니 생각보다 수월해졌다. 모방과 창조에 대한 생각 예전에는 항상 바닥부터 설계해서 프로그램을 만들어야만 한다고 생각했다. 물론 내가 생각하는 서비스가 아주 작은 단위 마저도 세상에 존재하지 않는다면 그렇게 해야할 것이다. 하지만 아직 내가 생각한 서비스들은 다 깃헙에 올라와있었고, 나는 아직 바닥부터 설계하기엔 역량이 부족한 상태였다. 다른 사람이 만든 것들을 기반으로 위에서 말한 과정을 반복하며 모방을 많이 해본다면 나중에는 창조도 수월하게 할 수 있을것이라고 생각된다. 검색 능력 게임을 만들면서 부딛히는 이슈가 많다보니 생각보다 나의 검색능력이 향상되어 있었다. 일단 누군가에게 물어보기 전에 내 문제가 뭔지 정의하고 구글링을 했다. 구글링도 한글로 하다가 점점 영어로 구글링을 하기 시작했다. 진짜 안찾아지는것도 키워드만 조금 바꾸면 다 나왔다 ( 오 구글 신이여… ) 지금은 모른다 -&gt; 문제를 정의해서 키워드를 뽑아낸다 -&gt; 구글링한다 -&gt; 해결! 여러 경우를 생각해보고 비교 선택하기 ( 로직 또는 라이브러리 ) 맨 처음에는 로직을 짜거나, 다른 라이브러리를 선택할 때 그냥 처음 나오는 제일 쉬워보이는 것으로 가져다가 썼다. 그런데 이렇게 하다보니 생각보다 로직이 꼬인다거나, 예외가 너무많이 발생해서 폭탄을 계속 밟아가면서 일을 진행한다거나, 라이브러리가 내가 하려는 것과는 조금 안맞는 것이 있다거나 하였다. 그래서 로직이나 라이브러리를 선택할 때 적어도 3가지 경우를 생각 해보고 각각의 장단점을 파악해서 감당할 만한 단점이 있는 것으로 또는 꼭 필요한 장점이 있는 것으로 선택해서 사용하는 습관이 생겼다. 코드로 바로 들어가는 것 보다 구조를 생각하고 어느정도 구상을 하고 나서 들어가는 편이 삽질의 빈도도 적고 프로그램의 퀄도 높아진다. 이걸 깨달은 것은 개선이 아닌 창조를 시도해 보면서이다. 이제 어느정도 게임을 개선시키고, 확장시키는것은 된다고 생각해서 바닥부터 만들기를 시도했었다. 머릿속으로 어느정도의 실행 흐름만 생각하고 나서 코드로 들어갔다. 그런데 만들다보니 이 흐름으로 만들기엔 비 효율적이고, 어떤 구조는 나올수가 없는 구조고 하는 일이 발생했다. 그렇게 한가지 게임을 만들면서 삽질을 수백번 했고 퀄리티도 그렇게 좋지 못했다. 그래서 그냥 처음에 설계를 하고 코드를 짜봤더니 설계는 처음이라 시간이 좀 걸렸지만 코드를 짜는데 그렇게 오랜 시간이 걸리지 않았다. 다음 프로젝트 부터는 처음에 어느정도의 설계를 진행 해보고 개발에 들어갈 생각이다. 안돼는건 계속 잡고있어도 안된다. 어떤 것을 만들다보면 분명 막히는 부분이 생긴다. 예를들어 테트리스를 온라인 멀티플레이 게임으로 만들면서도 서버도 처음이고 웹 자체가 처음이어서 어떻게 해야할지 몰라서 이리저리 찾아보기만 하고 일이 진행이 안됐다. 머릿속이 막혀서, 고정관념에 박혀버려서 일이 진행이 안돼는 상황이었다. 그래서 과감하게 놓고 다른 게임을 만들거나 다른 작업을 하고 다시 돌아왔다. 그랬더니 그 작업에서 새로 배운것들, 새로 적용해본것들 또는 내머리가 환기되었다. 또 이전에 했던것의 부족한 점, 개선점이 보이고 안풀리던것이 해결되었다. 안돼는건 계속 잡고있어도 안됀다. 과감히 다른일을 하고 돌아올줄도 알아야 한다. 무엇이든 만들 수 있겠다는 용기 작은 성공들을 해나가니까 나름 더 큰것도 완성하고 해낼 수 있겠다는 생각이 들었다. 아직 많이 부족하지만 이런 작은 성공들을 계속 쌓아보고, 다른 곳에서 인턴을 통해 실무 경험을 하면서 실력을 쌓아갈 예정이다. 양만 많이 하는것은 실력을 높이는데 도움이 되지 않는다. 나는 위에서 말했던 것 처럼 작은 성공들을 쌓기 위해 작은 토이프로젝트, 조금더 큰 프로젝트를 여러개 해볼 생각이다. 그러나 단순히 프로젝트만 하는것은 아무런 도움이 되지 않는다고 생각한다. 지금 글을 쓰면서 어떤것에서 배웠던점 부족한 점을 뽑아내는 것 처럼 어떤 프로젝트를 진행하고 나서 그것을 회고하고, 그 프로젝트를 통해 얻은 것들을 다음 프로젝트에 적용하고, 어떻게하면 내 실력을 더 키울 수 있을지 생각을해야 성장한다고 생각한다. 운동에서도 단순히 수영을 많이 한다고 다 수영선수가 되는 것이 아니다. 영법도 교정하고 호흡법도 조정하고 내 페이스를 위한 전략도 생각해야 좋은 선수가 되는 것인 것 같다. 내 커리어를 쌓고 내 실력을 쌓는 것도 이와 다르지 않다고 생각한다. 완성도에 대한 고민 아직 쪼렙 개발자다보니 내가 만든것이 완성도가 그렇게 높진 않다. 하지만 완성도에 너무 집착해도 일이 진행이 안돼고 재미도 떨어진다. 그리고 내가 완성도라고 하는 범주에는 디자인적인 요소가 많은 부분을 차지한다. 지금은 일단 어떤 구조를 설계하고 얼마나 효율적으로 개발하는지에 초점을 맞추고 디자인은 차차 어느정도 기본 소양이라도 채워 나가야겠다. 마무리생각보다 게임을 만들면서 많은 부분을 배운 것 같다. 그리고 글에 그 전부를 담아내지는 못한 기분이다. 앞으로 글을 계속 써 나가면서 내 생각을 표현하는 힘을 더 키워야겠다.","link":"/2017/12/07/learn-from-toy-project/"},{"title":"Flutter Plugin 만들기 - part1 Flutter Plugin 프로젝트 생성하기","text":"이야기를 하기에 앞서, 이 글은 네가지 파트로 나뉘어져 있습니다. 각 글을 나눈 기준은 제가 항상 Flutter로 개발하면서 작업을 나누는 단위입니다. 각 단위 내에서도 더 작게 쪼개지지만 플랫폼 관련 기능을 구현할 때는 Flutter -&gt; iOS -&gt; Android 순서로 작업합니다. (Android보다 iOS쪽이 제약이 많기 때문에 기능 확인차 이렇게 하고있습니다.) Flutter plugin 만들기 part1 - Create Flutter Plugin Flutter plugin 만들기 part2 - iOS 환경 세팅 (Swift) 및 개발하기 Flutter plugin 만들기 part3 - Android 환경 세팅 및 개발하기 Flutter Plugin 만들기 part4 - 플러그인 배포하기 Plugin?우리는 여러 플랫폼에서 어떤 프로그램을 개발할 때 수 많은 라이브러리들을 가져다가 쓴다. iOS는 CocoaPods.org, Web에서 Javascript로 개발할 때는 npm | build amazing things 이 대표적이다. 이와 마찬가지로 Flutter에는 pub.dev라는 곳이 존재하며 여기엔 이런 저런 플러그인들이 올라와있으며, 손쉽게 다운로드 해서 사용할 수 있다. 개발할 때 우리는 간단한 기능조차 라이브러리를 사용하는 등의 남용을 하지는 말아야 하지만, 필요한 기능을 제공하는 적당한 규모의 라이브러리를 사용하는 것은 개발속도를 높여주며 효율성을 높여준다. 이렇게 라이브러리를 만들어 두면 개발할때 바퀴를 재발명 하지 않아 효율적이고 모듈화를 통해 코드간 디펜던시를 줄여주며 안정적인 소프트웨어를 만들 수 있으며, 다른 사람들도 내가 만들어둔 라이브러리와 다른 라이브러리를 조합하여 또 다른 소프트웨어를 만들 수 있어 선순환이 된다. 우리는 Plugin을 Flutter에서 어떻게 생성하고, 개발하며 어떻게 배포 하는지를 알아볼 것이다. Plugin 생성하기 플러그인 생성1flutter create --template=package YOUR_PACKAGE_NAME 보통 flutter create YOUR_PROJECT_NAME 이런식으로 작성하면 보통의 Flutter 프로젝트가 생성되지만, —template=package 옵션을 주면 Plugin을 생성할 수 있다. 플랫폼 레벨의 기능 사용을 위해 Android, iOS쪽의 코드를 작성해두어야 하는 라이브러리기본적으로 iOS는 swift, Android는 kotlin으로 생성된다. 1flutter create --org YOUR_ORGANIZATION_NAME --template=plugin YOUR_PACKAGE_NAME 만약 YOUR_ORGANIZATION_NAME = com.example, YOUR_PACKAGE_NAME = hello 라면 hello 라는 이름의 Plugin project가 생성하며, android, ios의 패키지, 번들 이름이 com.example.hello 라고 생성된다. 만약 ios는 object - c, Android는 java로 개발하고 싶다면 아래의 명령어를 통해 생성하면 된다.1flutter create —template=plugin -i objc -a java YOUR_PACKAGE_NAME Plugin 구성123456789. # 패키지 루트+— ios # iOS part+— android # Android part+— lib # Flutter part+— example # 패키지의 샘플 어플리케이션| +— ios # example application의 iOS 플랫폼 part| +— android # example application의 Android 플랫폼 part| +— lib # example application의 Flutter part+— test iOS, Android part에서 각 플랫폼의 네이티브 코드를 통해 네이티브 기능을 사용해 볼 것이며 각 플랫폼의 다른 라이브러리도 추가해서 사용해 볼 것 이다. 중요한 부분이 example이다. example은 그냥 샘플 어플리케이션이라고 생각하겠지만 각 iOS, Android 코드를 짤때 example 내부의 iOS, Android 프로젝트를 열어서 개발해야한다! 그리고 개발하면서 자연스럽게 샘플 어플리케이션이 만들어지며 이 플러그인을 사용하는 개발자들은 사용 예시를 쉽게 볼 수 있다. (Flutter 측의 의도일수도 있겠다) lib는 네이티브와 연결되는 부분이다. method channel, event channel을 call 하여 각 플랫폼과 통신한다. Android, iOS 개발을 위해 build를 먼저 해줘야함 cd example flutter build apk // for android flutter build ios —no-codesign // for ios 생성되는 코드 설명이 글을 보고있는 Plugin을 생성하고자 하는 분들은 이미 Flutter가 네이티브와 통신하는 과정들을 다 이해하고 계시겠지만 그래도 약간의 설명을 더하고자 한다. lib/YOUR_PLUGIN_NAME.dart 1234567891011121314import 'dart:async';import 'package:flutter/services.dart';class YOUR_PLUGIN_NAME { // Method channel을 생성한다. static const MethodChannel _channel = const MethodChannel('YOUR_PLUGIN_NAME'); static Future&lt;String&gt; get platformVersion async { // Method channel에 등록되어있는 getPlatformVersion 이라는 메소드를 call 해서 platform version을 받아온다. final String version = await _channel.invokeMethod('getPlatformVersion'); return version; }} ios/Classes/SwiftYourPlugin.swift 123456789101112131415161718import Flutterimport UIKitpublic class SwiftYourPlugin: NSObject, FlutterPlugin { // register 메소드가 내부적으로 불리며 해당 Plugin class를 Flutter와 연결한다. public static func register(with registrar: FlutterPluginRegistrar) { // 메소드 채널 생성 let channel = FlutterMethodChannel(name: \"YOUR_PLUGIN_NAME\", binaryMessenger: registrar.messenger()) let instance = SwiftYourPlugin() // 메소드 채널에서 call되어 오는 메세지를 받기 위해 현재 Plugin을 등록 registrar.addMethodCallDelegate(instance, channel: channel) } public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) { // 원래는 call.method에서 getPlatformVersion이 오면 result로 systemVersion을 넘겨줘야하는데 생성되는 예제에서는 handle 메소드가 불리면 바로 넘겨주고 있다. result(\"iOS \" + UIDevice.current.systemVersion) }} android/src/main/kotlin/com/yourorgname/yourpackagename/YourPlugin.kt 123456789101112131415161718192021222324252627package com.yourorgname.yourpackagenameimport io.flutter.plugin.common.MethodCallimport io.flutter.plugin.common.MethodChannelimport io.flutter.plugin.common.MethodChannel.MethodCallHandlerimport io.flutter.plugin.common.MethodChannel.Resultimport io.flutter.plugin.common.PluginRegistry.Registrarclass YourPlugin: MethodCallHandler { // 위의 iOS의 설명과 같이 이 Handler를 Flutter에 등록한다. companion object { @JvmStatic fun registerWith(registrar: Registrar) { val channel = MethodChannel(registrar.messenger(), \"YOUR_PLUGIN_NAME\") channel.setMethodCallHandler(YourPlugin()) } } override fun onMethodCall(call: MethodCall, result: Result) { // 위에서 설명했던 바와 같이 getPlatformVersion method가 call되면 결과값으로 system version을 넘겨준다. if (call.method == \"getPlatformVersion\") { result.success(\"Android ${android.os.Build.VERSION.RELEASE}\") } else { result.notImplemented() } }} Flutter 쪽에서 method channel에 getPlatformVersion 메소드를 call 한다. 플랫폼 별로 대응 해서 Flutter 쪽에 응답을 준다. ios는 handle 메소드에서 result(~~)를 통해 응답한다. androidn 또한 handle 메소드에서 result.success(~~)를 통해 응답한다. 어떤 앱을 만들면서 이야기를 진행할까?회사에서 하는 작업 중 사용자가 입력한 Wi-Fi ssid, password를 가지고 해당 ap에 연결하는 작업이 있었고, 이 부분을 플러그인으로 만들면 좋겠다고 생각했었다. Android에서는 wifi를 scan, 연결, 연결 해제가 가능하지만 ios는 scan이 불가능하며 오직 ssid와 password를 가지고 연결하는 것이 가능하다(iOS 11 이상). iOS 10 이하의 사용자들은 지원 안하는건가? 라는 생각을 할 수 있지만 • Apple devices iOS version share worldwide 2016-2019 | Statista 여길 보면 10 이하 사용자가 5%정도 되는걸 알 수 있으며 최소 지원 버전을 11로 잡는게 문제 없을 것으로 판단하였다. 따라서 우리는 wifi를 연결하는 공통적인 기능을 플러그인으로 구현 해 볼 것이다! 순서는 역시 Flutter -&gt; iOS -&gt; Android 이다. Flutter part 코드 lib/wifi_connector.dart 123456789101112import 'dart:async';import 'package:flutter/services.dart';import 'package:flutter/widgets.dart';class WifiConnector { static const MethodChannel _channel = const MethodChannel('wifi_connector'); static Future&lt;bool&gt; connectToWifi({@required ssid, password}) async { return await _channel.invokeMethod('connectToWifi'); }} 각 플랫폼의 handle 메소드 내부에서 connectToWifi 라는 메소드를 handle 하도록 구현 할 것이며, 현재는 그 부분이 각 플랫폼에 구현되어있다고 생각하며, connect 성공시 true, 실패시 false가 온다고 가정하고 메소드를 구현해 두었다. Flutter 쪽에서 connectToWifi() 메소드 실행 iOS, Android 쪽에서 해당 기능 handle Flutter 쪽에서 성공 여부 return 테스트를 위한 UI는 example 앱에 간단히 가운데에 text field 두개, 확인 버튼 한개가 있는 뷰를 만들어 두었다. 이로써 Flutter 쪽의 구현은 완료되었으며, 다음글에서는 iOS쪽부터 기능 구현을 진행해보자.","link":"/2019/11/10/make-flutter-plugin-part1/"},{"title":"Flutter plugin 개발하기 - part3 Android 환경 세팅 (Kotlin) 및 개발하기","text":"이야기를 하기에 앞서, 이 글은 네가지 파트로 나뉘어져 있습니다. 각 글을 나눈 기준은 제가 항상 Flutter로 개발하면서 작업을 나누는 단위입니다. 각 단위 내에서도 더 작게 쪼개지지만 플랫폼 관련 기능을 구현할 때는 Flutter -&gt; iOS -&gt; Android 순서로 작업합니다. (Android보다 iOS쪽이 제약이 많기 때문에 기능 확인차 이렇게 하고있습니다.) Flutter plugin 만들기 part1 - Create Flutter Plugin Flutter plugin 만들기 part2 - iOS 환경 세팅 (Swift) 및 개발하기 Flutter plugin 만들기 part3 - Android 환경 세팅 및 개발하기 Flutter Plugin 만들기 part4 - 플러그인 배포하기 프로젝트 열기 필자는 Flutter plugin을 개발할 때 난관이 “어느 프로젝트를 열어야 하는거지?” 였다. iOS쪽은 애를 먹었지만, Android쪽은 안드로이드 스튜디오에서 여니 찾기 편했다. iOS와 동일하게 example 내부의 Android 프로젝트를 열어서 개발해야한다! 백문이 불여일견! Android studio로 example Android 프로젝트를 열었을 때의 directory tree를 살펴보자. Android studio에서 wifi_connector/example/android 를 열면 된다. Android Studio에서 디렉토리 뷰를 project뷰로 설정하면 3가지 프로젝트 (app, wifi_connector, android)가 잡혀있는 것을 볼 수 있다. 1번은 wifi_connector 내부에 있는 파일들이 우리가 개발중인 플러그인의 android쪽이이다. wifi 연결하는 기능을 저 내부에 WifiConnectorPlugin에 개발하고, method channel을 call해서 사용하면 된다. 2번은 android 내부에 있는 파일들은 example 프로젝트의 파일들이다. 우리는 여기서 건드릴것이 없다. 플러그인에서 구현된 기능을 flutter쪽에서 가져다 쓸 것이기 때문이다 코드 설명Plugin이 Activity와 연결될 때 context를 받아와서 저장 해 두고 사용한다.12345678910111213141516171819202122232425262728293031323334package com.wonjerry.wifi_connectorclass WifiConnectorPlugin : MethodCallHandler, FlutterPlugin { companion object { @JvmStatic fun registerWith(registrar: Registrar) { val instance = WifiConnectorPlugin() // activity의 context를 받아오기위해 FlutterPlugin을 상속받고, interface들을 구현한다. instance.onAttachedToEngine(registrar.context(), registrar.messenger()) } } private var activityContext: Context? = null private var methodChannel: MethodChannel? = null // Plugin이 Flutter Activity와 연결되었을 때 불리는 callback method이다. override fun onAttachedToEngine(binding: FlutterPlugin.FlutterPluginBinding) { onAttachedToEngine(binding.applicationContext, binding.flutterEngine.dartExecutor) } // Plugin이 Flutter Activity와 연결이 떨어졌을 때 불리는 callback method이다. override fun onDetachedFromEngine(p0: FlutterPlugin.FlutterPluginBinding) { activityContext = null methodChannel?.setMethodCallHandler(null) methodChannel = null } // Plugin이 Flutter Activity와 연결되었을 때 context를 저장 해 둔다. private fun onAttachedToEngine(context: Context, messenger: BinaryMessenger) { activityContext = context methodChannel = MethodChannel(messenger, \"wifi_connector\").apply { setMethodCallHandler(this@WifiConnectorPlugin) } } method channel을 통해 온 call을 handling 한다.123456override fun onMethodCall(call: MethodCall, result: Result) { when (call.method) { \"connectToWifi\" -&gt; connectToWifi(call, result) else -&gt; result.notImplemented() }} ssid, password를 받아서 wifi에 연결한다.12345678910111213141516171819202122232425262728293031323334353637383940414243private fun connectToWifi(call: MethodCall, result: MethodChannel.Result) { val argMap = call.arguments as Map&lt;String, Any&gt; val ssid = argMap[\"ssid\"] as String val password = argMap[\"password\"] as String? // 비밀번호가 있냐 없냐에 따라 wifi configration을 설정한다. val wifiConfiguration = if (password == null) { WifiConfiguration().apply { SSID = wrapWithDoubleQuotes(ssid) status = WifiConfiguration.Status.CURRENT allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE) } } else { WifiConfiguration().apply { SSID = wrapWithDoubleQuotes(ssid) preSharedKey = wrapWithDoubleQuotes(password) status = WifiConfiguration.Status.CURRENT allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK) } } val wifiManager = activityContext?.applicationContext?.getSystemService(Context.WIFI_SERVICE) as WifiManager with(wifiManager) { if (!isWifiEnabled) { isWifiEnabled = true } // 위에서 생성한 configration을 추가하고 해당 네트워크와 연결한다. addNetwork(wifiConfiguration) configuredNetworks.find { network -&gt; network.SSID == wrapWithDoubleQuotes(ssid) }?.let { network -&gt; disconnect() enableNetwork(network.networkId, true) reconnect() result.success(true) } ?: let { result.success(false) } }} wifi 권한Android에서 wifiManager를 통해 programming 적으로 wifi를 제어하기 위해서는 권한이 필요하다. AndroidManifest.xml에 권한 두가지를 추가 해 준다. 123456&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.wonjerry.wifi_connector&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&lt;/manifest&gt; Total code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.wonjerry.wifi_connectorimport android.content.Contextimport android.net.wifi.WifiConfigurationimport android.net.wifi.WifiManagerimport io.flutter.embedding.engine.plugins.FlutterPluginimport io.flutter.plugin.common.BinaryMessengerimport io.flutter.plugin.common.MethodCallimport io.flutter.plugin.common.MethodChannelimport io.flutter.plugin.common.MethodChannel.MethodCallHandlerimport io.flutter.plugin.common.MethodChannel.Resultimport io.flutter.plugin.common.PluginRegistry.Registrarclass WifiConnectorPlugin : MethodCallHandler, FlutterPlugin { companion object { @JvmStatic fun registerWith(registrar: Registrar) { val instance = WifiConnectorPlugin() // activity의 context를 받아오기위해 FlutterPlugin을 상속받고, interfacee들을 구현한다. instance.onAttachedToEngine(registrar.context(), registrar.messenger()) } } private var activityContext: Context? = null private var methodChannel: MethodChannel? = null // Plugin이 Flutter Activity와 연결되었을 때 불리는 callback method이다. override fun onAttachedToEngine(binding: FlutterPlugin.FlutterPluginBinding) { onAttachedToEngine(binding.applicationContext, binding.flutterEngine.dartExecutor) } // Plugin이 Flutter Activity와 연결이 떨어졌을 때 불리는 callback method이다. override fun onDetachedFromEngine(binding: FlutterPlugin.FlutterPluginBinding) { activityContext = null methodChannel?.setMethodCallHandler(null) methodChannel = null } // Plugin이 Flutter Activity와 연결되었을 때 context를 저장 해 둔다. private fun onAttachedToEngine(context: Context, messenger: BinaryMessenger) { activityContext = context methodChannel = MethodChannel(messenger, \"wifi_connector\").apply { setMethodCallHandler(this@WifiConnectorPlugin) } } override fun onMethodCall(call: MethodCall, result: Result) { when (call.method) { \"connectToWifi\" -&gt; connectToWifi(call, result) else -&gt; result.notImplemented() } } private fun connectToWifi(call: MethodCall, result: Result) { val argMap = call.arguments as Map&lt;String, Any&gt; val ssid = argMap[\"ssid\"] as String val password = argMap[\"password\"] as String? // 비밀번호가 있냐 없냐에 따라 wifi configration을 설정한다. val wifiConfiguration = if (password == null) { WifiConfiguration().apply { SSID = wrapWithDoubleQuotes(ssid) status = WifiConfiguration.Status.CURRENT allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE) } } else { WifiConfiguration().apply { SSID = wrapWithDoubleQuotes(ssid) preSharedKey = wrapWithDoubleQuotes(password) status = WifiConfiguration.Status.CURRENT allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK) } } val wifiManager = activityContext?.applicationContext?.getSystemService(Context.WIFI_SERVICE) as WifiManager with(wifiManager) { if (!isWifiEnabled) { isWifiEnabled = true } // 위에서 생성한 configration을 추가하고 해당 네트워크와 연결한다. addNetwork(wifiConfiguration) configuredNetworks.find { network -&gt; network.SSID == wrapWithDoubleQuotes(ssid) }?.let { network -&gt; disconnect() enableNetwork(network.networkId, true) reconnect() result.success(true) } ?: let { result.success(false) } } } private fun wrapWithDoubleQuotes(text: String) = \"\\\"$text\\\"\"} 실제 동작 확인자 이제 example앱을 빌드하고, ssid, password를 입력하여 wifi에 연결 해 보자! 성공적으로 wifi에 연결되었다! 다음 글에서는 지금까지 구현한 wifi connector를 pub.dev에 배포해보자!","link":"/2019/11/24/make-flutter-plugin-part3/"},{"title":"Flutter plugin 만들기 - part2 iOS 환경 세팅 (Swift) 및 개발하기","text":"이야기를 하기에 앞서, 이 글은 네가지 파트로 나뉘어져 있습니다. 각 글을 나눈 기준은 제가 항상 Flutter로 개발하면서 작업을 나누는 단위입니다. 각 단위 내에서도 더 작게 쪼개지지만 플랫폼 관련 기능을 구현할 때는 Flutter -&gt; iOS -&gt; Android 순서로 작업합니다. (Android보다 iOS쪽이 제약이 많기 때문에 기능 확인차 이렇게 하고있습니다.) Flutter plugin 만들기 part1 - Create Flutter Plugin Flutter plugin 만들기 part2 - iOS 환경 세팅 (Swift) 및 개발하기 Flutter plugin 만들기 part3 - Android 환경 세팅 및 개발하기 Flutter Plugin 만들기 part4 - 플러그인 배포하기 프로젝트 열기 필자는 Flutter plugin을 개발할 때 난관이 “어느 프로젝트를 열어야 하는거지?” 였다. 그냥 Flutter에서 생성해준 디렉토리 내에서 ios 폴더를 들어가 보면 Runner가 없을 뿐더러 Runner.xcworkspace 파일도 없었다…!! 이전 글에서 얘기했듯이 example 내부의 iOS 프로젝트를 열어서 개발해야한다! 이전 글에서 example 폴더에서 flutter build iOS —no-codesign 명령어를 실행 시켜 줬었는데, 이때 example/ios 디렉토리에 있는 Runner.xcworkspace를 xcode로 열어준다. open example/ios/Runner.xcworkspace 백문이 불여일견! xcode로 example ios 프로젝트를 열었을 때의 directory tree를 살펴보자 크게 두개의 프로젝트가 있다. Runner와 Pods Runner는 우리 어플리케이션의 내부적인 이름입니다. Pods Pods는 cocoapods에서 다운받은 라이브러리를 관리하는 프로젝트이다. 우리의 flutter plugin 프로젝트는 iOS쪽에서 본다면 “cocoapods에 올라가있는 라이브러리”로 해석 할 수 있다. 우리가 중점적으로 봐야할 것은 Development Pods이다. wifi_connector/../../example/ios/.symlinks/plugin/wifi_connector/ios/Classes/SwiftWifiConnectorPlugin.swift 이 파일이 우리가 개발할 파일이며, Classes 디렉토리 내부에 여러 swift 파일을 만들면서 개발을 진행하면 된다. wifi_connector/../Pod/wifi_connector.podspec 이 파일은 Podfile과 같이 “내가 플러그인에서 사용할 라이브러리를 정의해 두는 곳” 이라고 생각하면 된다 Podfile과 문법은 약간 다르지만, 대부분이 비슷하며 문서화가 잘 되어있다. - podspec documentation 코드를 살펴보자!method call handling12345678public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) { switch call.method { case \"connectToWifi\": self.connectToWifi(call, result) default: result(FlutterMethodNotImplemented) } } Flutter 측에서 method channel을 통해 connectToWifi method를 call 하면 이 handle method가 call 된다. call에는 두가지 property가 존재한다. method: flutter 쪽에서 call한 method의 이름 (String) arguments: flutter 쪽에서 method를 call 할때 argument를 넣어줄 수 있는데 그 값을 argument로 전달 받을 수 있다. 보통 String, int, bool, map 등등을 전달 할 수 있다. result는 callback method이다. result(String, int, bool, map)등등을 응답으로 보낼 수 있다. result에 FutterError(code, message, detail), FlutterMethodNotImplemented를 응답으로 보내서 platform exception을 발생 시킬 수 있다. 보통 platform의 error를 flutter 쪽으로 propagate 시키기 위해 사용한다. connect to wifi123456789101112131415161718192021222324252627282930313233343536373839404142private func connectToWifi(_ call: FlutterMethodCall, _ result: @escaping FlutterResult) { // Flutter 쪽에서 arguments로 map을 보낸 것을 이렇게 Dictionary로 parsing해서 사용한다. guard let argMaps = call.arguments as? Dictionary&lt;String, Any&gt;, let ssid = argMaps[\"ssid\"] as? String, let isWEP = argMaps[\"isWEP\"] as? Bool else { result(FlutterError(code: call.method, message: \"Missing argument: ssid\", details: nil)) return } var hotspotConfiguration: NEHotspotConfiguration if isWEP { result(FlutterError(code: call.method, message: \"WEP is not supported\", details: nil)) return } if let password = argMaps[\"password\"] as? String { hotspotConfiguration = NEHotspotConfiguration(ssid: ssid, passphrase: password, isWEP: false) } else { hotspotConfiguration = NEHotspotConfiguration(ssid: ssid) } hotspotConfiguration.lifeTimeInDays = 1 // 연결을 시도하고, 성공 여부를 callback으로 전달받는다. NEHotspotConfigurationManager.shared.apply(hotspotConfiguration) { (error) in if let error = error { switch error { case NEHotspotConfigurationError.userDenied: result(false) break case NEHotspotConfigurationError.alreadyAssociated: result(true) break default: result(FlutterError(code: call.method, message: error.localizedDescription, details: nil)) } } else { result(true) } } } 이전 글에서 Flutter에서 connectToWifi method를 call 할 때 아래와 같은 방식으로 argument를 넘겨줬다.123static Future&lt;bool&gt; connectToWifi(String ssid, {String password, bool isWEP = false}) async { return await _channel.invokeMethod('connectToWifi', {'ssid': ssid, 'password': password, 'isWEP': isWEP}); } 이때 넘겨준 argument를 call.arguments를 통해 받을 수 있다. 다음 코드들은 ios에서 wifi에 연결을 시도하는 코드이며, 사용자에게 alert가 뜨게된다. Total code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import Flutterimport UIKitimport NetworkExtensionimport SystemConfiguration.CaptiveNetworkpublic class SwiftWifiConnectorPlugin: NSObject, FlutterPlugin { public static func register(with registrar: FlutterPluginRegistrar) { let channel = FlutterMethodChannel(name: \"wifi_connector\", binaryMessenger: registrar.messenger()) let instance = SwiftWifiConnectorPlugin() registrar.addMethodCallDelegate(instance, channel: channel) } public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) { switch call.method { case \"connectToWifi\": self.connectToWifi(call, result) default: result(FlutterMethodNotImplemented) } } private func connectToWifi(_ call: FlutterMethodCall, _ result: @escaping FlutterResult) { // Flutter 쪽에서 arguments로 map을 보낸 것을 이렇게 Dictionary로 parsing해서 사용한다. guard let argMaps = call.arguments as? Dictionary&lt;String, Any&gt;, let ssid = argMaps[\"ssid\"] as? String, let isWEP = argMaps[\"isWEP\"] as? Bool else { result(FlutterError(code: call.method, message: \"Missing argument: ssid\", details: nil)) return } var hotspotConfiguration: NEHotspotConfiguration if isWEP { result(FlutterError(code: call.method, message: \"WEP is not supported\", details: nil)) return } if let password = argMaps[\"password\"] as? String { hotspotConfiguration = NEHotspotConfiguration(ssid: ssid, passphrase: password, isWEP: false) } else { hotspotConfiguration = NEHotspotConfiguration(ssid: ssid) } hotspotConfiguration.lifeTimeInDays = 1 // 연결을 시도하고, 성공 여부를 callback으로 전달받는다. NEHotspotConfigurationManager.shared.apply(hotspotConfiguration) { (error) in if let error = error { switch error { case NEHotspotConfigurationError.userDenied: result(false) break case NEHotspotConfigurationError.alreadyAssociated: result(true) break default: result(FlutterError(code: call.method, message: error.localizedDescription, details: nil)) } } else { result(true) } } }} 잠깐! 이 코드를 붙여넣기 하면 당연히 에러가 발생할 것 이다.ssid, password를 사용해서 wifi를 연결하기 위해서는 iOS11 버전 이상이어야 하며, Hotspot Configuration Capability가 필요하다. xcode에서 Runner를 클릭하자 General에서 Development Info &gt; Development target을 11.0으로 설정하자! Capability에서 Hotspot Configuration을 켜주자 Plugin의 wifi_connector.pubspec에서 development_target을 11.0으로 설정한다! 1234567891011121314151617181920## To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html#Pod::Spec.new do |s| s.name = &apos;wifi_connector&apos; s.version = &apos;0.0.1&apos; s.summary = &apos;A new flutter plugin project.&apos; s.description = &lt;&lt;-DESCA new flutter plugin project. DESC s.homepage = &apos;http://example.com&apos; s.license = { :file =&gt; &apos;../LICENSE&apos; } s.author = { &apos;Your Company&apos; =&gt; &apos;email@example.com&apos; } s.source = { :path =&gt; &apos;.&apos; } s.source_files = &apos;Classes/**/*&apos; s.public_header_files = &apos;Classes/**/*.h&apos; s.dependency &apos;Flutter&apos; s.ios.deployment_target = &apos;11.0&apos;end 자 이렇게 하면 ios쪽 환경 구축 및 코드 구현은 끝났다. 실제로 wifi 연결 시도해보자! 연결이 성공적으로 진행되었다 iOS쪽 구현 완료! 다음 글에서는 android 파트를 구현해보자.","link":"/2019/11/13/make-flutter-plugin-part2/"},{"title":"Programming paradigm과 Flutter UI","text":"Flutter를 공부하다보니 Flutter는 Declaravitve Programming 방식을 따르며 어떤 Function에 application state를 input으로 넣으면 UI가 생성되도록 한다고 한다. 이제까지는 아무 의구심 없이 Flutter UI를 이런 방식으로 만들어 왔지만 Declarative Programming은 뭔지 또 그와 반대되는 Imperative Programming은 뭔지 다른 Programming Paradigm은 어떤 것들이 있는지 파보려고 한다. Introduce 🛫어떤 프로그램을 만들 때 그 규모가 커짐에 따라 Complexity가 높아진다. 그리고 이 커진 Complexity는 프로그래머의 가장 큰 적이다. Complexity가 높아지면 높아질수록 우리는 어떤 문제가 생겼을 때 추적하기 어려워지며 관리가 힘들어진다. Complexity가 작을수록 사람이 이해하기 쉬워지고, 문제가 생겼을 때 디버깅을 하기 쉬워진다. 프로그래머는 이 Complexity를 관리하는 데에 많은 노력을 쏟는다. 그렇다면 Complexity를 어떻게 관리해야 할까? Programming Paradigm은 프로그래머가 Complexity를 관리하기 위한 여러 방식들을 제시한다. 각 paradigm이 제시하는 방식에는 장단점이 있고, 우리는 우리가 만드는 프로그램의 성격에 따라 맞는 paradigm을 사용하면 된다. Paradigm? 🤔Paradigm은 다른 말로 하면 프로그래밍 스타일이라고 할 수 있다. 이 스타일은 우리가 프로그램을 만드는 방식에 관한 것이지, 프로그래밍 언어에 국한되지는 않는다. 현재 수많은 프로그래밍 언어들이 나오고 있고 각 언어의 문법이 있다. 하지만 이 문법과는 별개로 프로그래밍할 때 어떤 전략으로 프로그램을 구현할 것 인가를 생각해야 하는데 이 전략이 바로 paradigm 이다. [Programming Paradigm의 종류] 📗 Imperative programming paradigm한국말로 번역하면 명령형 프로그래밍 방식이다. Imperative라는 단어는 I command 라는 의미를 가지는 라틴어 impero 라는 단어에서 유래되었다. 이 패러다임은 이 단어의 의미와 정확히 일치한다. 우리는 컴퓨터가 수행할 작업들을 순서대로 일일이 명령하며, 컴퓨터는 이것을 수행한다. 수행할 task를 순서대로 작성함 어떤 상태들을 가지고 있음 task가 하나하나 순서대로 실행됨 실행 될 때마다의 결과를 state에 저장함 Imperative programming에서는 task들의 순서가 매우 중요하다. 이전 task의 결과가 다음 task의 input으로 들어가게 되는데 이 순서가 바뀌게 되면 원하는 결과 값을 얻을 수 없기 때문이다. 예시를 들어보자. 1234567891011void main() { int num1 = 1; num1 *= 4; num1 = (num1 / 2).floor(); print(num1); // 2 int num2 = 1; num2 = (num2 / 2).floor(); num2 *= 4; print(num2); // 0} 위 예시는 1에 4를 곱하고 2를 나눈 것의 몫을 결과 값으로 가지는 것과 1을 2로 나눈 것의 몫과 4를 곱한 것의 결과값을 print 한 것이다. 위의 예시와 같이 순서대로 수행하지 않으면 input이 달라지기 때문에 result가 달라진다. Procedural programming parardigmImperative parardigm 의 한 종류인 procedural programming을 살펴보자. 한국말로 해석하면 절차지향 프로그래밍이라고 할 수 있겠다. Procedural programming은 어떤 명령을 어떤 절차들로 쪼갠 것이다. 하지만 이 의미가 절차 == 함수는 아니다. 함수는 결과 값을 리턴하지만 절차는 어떠한 값도 리턴하지 않는다. 좀 더 자세히 얘기해보자. 함수들은 해당 스코프 내에서 최대한 작은 side effect(프로그래밍에서 side effect란 어떤 변화가 일어나는 행위이다.)를 발생시키며 항상 같은 input이 들어오면 같은 output을 내도록 설계되어있다. 절차는 어떠한 값도 리턴하지 않으며 단지 원하는 만큼의 side effect를 발생시키는 데에 목적을 둔다. 예시를 보자. 12345678void main() { int sum = 0; for(int i = 1; i &lt; 11; i++) { sum += i; } print(sum);} 어떤 상태가 있고(sum), 최소 또는 최대가 아닌 원하는 만큼의 side effect를 발생시키고 있고(for loop 10 times), 아무런 값도 return하지 않는다. 🙋Procedural programming은 언제 사용하는 게 좋을까? 어떤 task들 간의 디펜던시가 있어서 꼭 순서대로 진행해야 할 때 중복되는 코드가 거의 없을 때 코드가 미래에 바뀔 일이 거의 없을 때 해당 프로젝트에 추가될 기능들이 미래에 거의 없다고 생각될 때 🙋Procedural programming를 왜 써야 할까? 쉽다 메모리를 적게 먹어서 효율적이다 Object oriented programming paradigmOOP는 코드를 모듈화할 수 있고, 실제 세계를 코드에 반영하기 쉽기 때문에 널리 쓰이고있는 programming paradigm이다. OOP는 Class, Abstraction, Encapsulation, Inheritance and Polymorphism 다섯 개의 특징을 가지고 있다. Class는 설계도이다. Object는 class의 인스턴스이며 Object는 상태와 행동을 가진다. Abstraction은 실제 구현과 인터페이스를 분리한다. Encapsulation은 어떤 Object의 내부 구현을 숨기는 과정이다. Inheritance는 Object간의 계층적인 관계를 가지게 한다. Polymorphism는 다른 타입의 Object들에게 같은 메세지를 받을 수 있게 하며 다른 결과물이 나오도록 한다. ⚠️하지만 의문이 하나 든다. 왜 OOP가 Procedural programming과 같은 범주인 imperative programming에 들어가는가?? imperative programming은 명령형 프로그래밍이며, 어떤 task를 순서대로 상세히 명령해야 하며 그 task들의 순서가 중요하다. 그러한 관점에서 OOP는 어떤 클래스들의 동작(메소드)들이 순서대로 동작해며 상호작용해야 하므로 imperative programming 범주에 들어간다. 🙋OOP는 언제 사용하는 게 좋을까? 프로그램을 만드는 여러명의 프로그래머가 있으며, 각자의 파트를 몰라도 될 때 프로그램 내에 많은 코드들이 재사용되어야할때 프로젝트의 내용이나 기능이 많이 추가되고 바뀔 것이 예상될때 🙋OOP를 왜 써야 할까? 상속을 통한 코드의 재사용 다형성을 통한 유연함 개발 생산성을 위해 (빠른 속도, 적은 비용) 높은 퀄리티의 소프트웨어를 위해 Parallel processing approach여러 작업을 processor에 나눠서 할당해줘야 할 때 병렬 작업을 한다. 각각을 쪼개서 동시에 처리하기 때문에 적은 시간 안에 테스크를 처리할 수 있다. 이 paradigm도 병렬처리시 테스트 순서가 중요하기 때문에, 그리고 어떻게 처리되어야 하는지 상세히 명령해야하기 때문에 imperative programming에 속한다. 📗 Declarative programming paradigmImperative programming과 반대되는 declarative programming은 한국어로 풀어 얘기하면 선언형 프로그래밍이다. 이또한 단어의 의미와 같이, 프로그래머가 프로그램을 구현할 때 단지 어떤 기능이 실행되었으면 좋겠다고 선언하는 것이며 그 상세한 구현에 대해서는 선언하지 않는다. 예를들어보자. Declarative programming은 마치 대통령이 각 장관에게 ~~일을 해주세요 하는 것과 같이 좀 더 큰 범주 내에서 명령을 할 뿐이고 실제로 각 파트의 장관들, 그 하위 계층에서는 어떤 일을 하는지 알지 못한다. 반대로 Imperative programming은 마치 맥도날드 지점장이 각 알바들에게 손님들에게 친절하게 해라 몇시부터 나와라 하는 등의 세세한 지시를 하는 것과 같다. 결론적으로 Imperative programming은 어떤 일을 어떻게 해야하는지를 나열하는 방식이라면 Declarative programming은 어떤 일을 해야하는지를 나열할 뿐 어떻게 해야하는지는 말해주지 않는다. 단지 선언한 대로 동작하기를 기대할 뿐이다. Logic programming paradigm이 패러다임은 이름 그대로 로지컬하게 로직을 풀어나간다. 예시를 보는게 가장 빠를듯 하다. 소크라테스는 사람이고, 모든 사람은 죽으며 따라서 소크라테스는 죽는다는 삼단 논법이 있다고 하자. 이걸 logic programming 으로 나타내면 12man(Socrates) // 소크라테스는 사람이다mortal(X) :- man(X) // :-기호는 if와 같다. 즉 X가 사람이면 X는 죽는다 위의 코드와 같이 선언해놓으면 어떤 X가 입력으로 들어오면 man인지 확인하고 man이면 mortal이라고 결과값을 뱉는다. 1?- mortal(Socrates) 위의 코드 한줄은 Socrates는 죽는가? 라는 의미를 가지며 위에 선언한 mortal(X) :- man(X) 식에 따라 X에는 Socrates가 들어가게 되고 Socrates는 죽는다는 결론이 나온다. 🙋Logic programming paradigm는 언제 사용하는게 좋을까? 철학적인 문제를 해결하거나 어떤 시스템을 구축할때 🙋Logic programming paradigm를 왜 써야할까? 코드를 구현하기 쉽다 디버깅이 쉽다 true, false로 모든 구조가 이루어져있으면 아주 빠르게 구현 가능하다 Functional programming paradigm함수형 프로그래밍은 요새 많이 각광받고있고 여기저기서 사용되고있다. 이 패러다임은 수학에 기초하고있으며 프로그래밍 언어와는 독립적인 개념이다. 함수형 프로그래밍의 원리는 수학적인 함수를 연속적으로 실행시키는 것이다. 모든 변수는 함수 내에 존재하며 짧은 함수들이 연속적으로 실행되면서 이전 output이 다음 input으로 들어가며 계산이 진행된다. 함수형 프로그래밍에서는 함수 내에 스코프가 아닌 외부 스코프에 있는 변수를 변화시키지 않는다. 오직 자신의 스코프에 있는 변수만 변화시키며 결과값을 리턴할 뿐이다. 예를들어보자. 어떤 수가 소수인지 아닌지 판단하는 코드가 존재한다. 1234567891011function isPrime(number) { for(let i = 2; i &lt;= Math.floor(Math.sqrt(number)); i++) { if (number % i == 0) { return false; } } return true;}isPrime(15) // return false 위의 코드에서는 외부 스코프의 변수를 변화시키지도 않는다. 인풋으로 들어온 number를 단지 sqrt와 floor를 통해 변화시키고 i와 비교할 뿐이다. floor, sqrt 는 단지 버림, 루트와 같은 동작을 한다고 메소드 이름이 지어졌을 뿐 내부 구현이 어떻게 되어있는진 모른다. 단지 선언할 뿐이다. 🙋Functional programming paradigm는 언제 사용하는게 좋을까? 수학적인 계산을 할때 병행 또는 병렬 처리를 작업을 해야하는 프로그램일때 🙋Functional programming paradigm를 왜 써야할까? 쉽고 빠르게 구현할 수 있다. (세부 구현은 신경 안쓰고 이어붙이기만 하면 되니까) 일반적인 목적의 함수들은 계속 재사용되기 때문에 개발 속도가 빠르다. 테스트, 디버깅이 쉽다. Related to Flutter 🛎️Flutter는 declarative programming 방식을 따른다. 물론 내부적으로 서버와 통신을 한다거나 앱의 목적에 따라서 procedural 방식을 따를수도 있고 OOP를 따르며 클래스들이 상호작용하고 상태를 바꾸게 할 수 있다. 하지만 UI를 만드는 방식은 확실히 declarative하다고 말할 수 있다. 123456789101112131415161718import 'package:flutter/material.dart';class TestWidget extends StatefulWidget { @override _TestWidgetState createState() =&gt; _TestWidgetState();}class _TestWidgetState extends State&lt;TestWidget&gt; { final String name = 'wonjerry'; @override Widget build(BuildContext context) { return Container( child: Text(name), ); }} build 메소드를 보자. 우리는 Container가 어떻게 구현되어있는진 모르겠지만 Container안에 Text라는 자식 위젯을 넣어줬다. Text또한 어떻게 구현되어있는진 모르겠지만 ‘wonjerry’라는 String을 넣어주어서 화면에 text를 띄우는 UI를 구현하였다. 전형적으로 구현에는 신경쓰지 않고 여러 선언을 통해 원하는 결과값을 도출해내는 Declarative programming 방식이다. 하지만 UI가 아닌 다른 부분에서는 helper class, model class, api 통신을 위한 class들에서는 OOP를 따르며 어떤 일련의 순서가 중요하며 어떻게 구현되어야하는지 일일이 써줘야 하는 부분도 있다. 생각해보면 우리가 보통 프로그래밍을 할 때는 프레임워크에서 뭔가를 제공해주지 않는 한 우리는 Imperative 하게 프로그래밍을 할 수 밖에 없다. 예를들면 api 통신을 할때 header를 뭘 넣고 어떤 method를 통해 어떤주소로 어떻게 request를 할것인지 일일히 작성한다. 하지만 우리는 구현해 나가면서 우리의 프로그램을 관리하기 쉽게, 디버깅하기 쉽고, 구조를 단순하게 구현하기 위해서 중복된 코드를 메소드로, class로 빼고 모듈화 시키면서 wrapping 하게 되며 이러한 과정을 통해 나온 메소드들을 마치 레고 블록을 쌓듯 imperative하게 조합시키면서 프로그램을 완성시키는듯 하다. Conclusion 🛬Programming paradigm들은 프로그램의 Complexity를 줄여준다. 모든 프로그래머는 어떤 패러다임을 따르는것이 좋겠다는 생각이 든다. 하지만 조금 더 생각을 해보면 요새 나온 프로그래밍 언어들은 특정한 패러다임을 따르면서 탄생되고, 코그를 짜면서 그 패러다임을 따르도록 유도한다. 어떤 특정한 하나의 패러다임을 따르는것은 멍청하다고 본다. 오히려 우리가 쓰는 프레임워크, 툴에서 어떤 패러다임을 따르며 만들어졌는지 파악하고 우리가 짜는 코드가 어떤 패러다임을 따르는지 느끼며 각 상황별 적절한 패러다임을 따르면 된다는 생각이 든다. 궁극적인 목적은 사람이 이해하기 쉽고, 단순하고, 모듈화 시키는 것이다. 그리고 이걸 이루면 디버깅 및 관리가 쉬운 코드를 짤 수 있다. 그리고 이러한 코드를 짜는 프로그래머가 좋은 프로그래머라는 생각이 든다.","link":"/2019/12/27/programming-paradigm/"},{"title":"오픈소스로 js, nodejs 익히기 part1","text":"나는 2017년 7월부터 웹 프로그래밍을 시작했고, 처음 자바스크립트를 배우기 시작하면서 그것을 익히기 위해 여러 오픈소스 게임을 분석해서 내가 생각하는 구조로 포팅하고 개선시키는 작업을 해 보았다. 그 과정에서 배운점을 적어보려고 한다. 자바스크립트 강의 듣기 일단 나는 자바스크립트를 전혀 몰랐기 때문에 생활 코딩에서 자바스크립트 강의를 빠르게 들으며 개념을 익혔다. 이때 그냥 내용 자체를 익힌것이 아닌 내가 기존에 알고 있던 자바나 C++과 비교하며 어떤점이 다른지 비교해가면서 차이점을 생각해가며 익혔다. 오픈소스 테트리스 분석하기 테트리스 게임을 처음으로 선택한 이유는 일단 내가 테트리스 게임을 좋아한다. 이미 남이 만들어놓은 소스가 굉장히 많기 때문에 여러 소스를 비교해보고 내가 이해할 수 있고 적당한 사이즈의 소스를 찾기 쉬웠다. 적당한 크기의 테트리스소스를 찾았고, 그것을 메소드 하나하나 분석하면서 어떻게 돌아가는지 머리속에 그려보고, 또 log를 찍어보며 어떻게 돌아가는지 추적해가며 구조를 파악하였다. 테트리스 게임의 구조 play 라는 main loop에서 0.4초마다 한번씩 테트리스 로직을 돌려서 gameover인지 체크한다. 테트리스 로직에서는 board와 block을 체크하면서 block이 아래로 내려갈 수 있는 상황인지, 더이상 못내려가고 그 자리에서 멈춰야 하는 상황인지, gameover 상황인지를 체크한다. 테트리스 로직에서 gameover라는 판정이 나지 않으면 redraw에서는 board와 block의 데이터를 바탕으로 dom element들을 다시 생성하고 body를 비우고 그것을 추가한다. 루프를 돌며 update -&gt; draw의 형태로 구성되어 있었다. 이렇게 파악한 구조를 바탕으로 나에게 맞게 변경하였다. 일단 나는 로직과 뷰가 붙어있는 것이 마음에 안 들었다. 그래서 뷰와 로직을 각각의 모듈로 분리하였다. 나는 main loop에 모든것이 다 들어있는 것이 마음에 안들었다. 그래서 tetris game ( main loop, key control ) 과 block 부분을 각각의 모듈로 분리하였다. 뷰 모듈과 block 모듈을 tetris game 모듈이 가지고 있는 형태로 바꾸어서 tetris game의 main loop을 실행시키는 형태로 변경하였다. 뷰와 로직이 교환하는 데이터는 game board 전체로 하였다. 이때는 어떻게 해야할지 몰라서 로직에서 모든 데이터를 board에 적용 시키면 그것을 뷰가 받아서 그려주는 방식으로 하였다. 이렇게 하니 기능별로 모듈이 나뉘어져서 오류가 발생했을 때 어느부분을 고쳐야 할지도 눈에 잘 보였고 구조도 머리속에 잘 그려졌다. 구조를 변경하고 나니, dom으로 element를 만들고 css를 적용시키는 작업이 나에겐 익숙하지 않고 비효율적으로만 보였다. 매회 만들고 부수고 만들고 부수는 작업이라니! 그래서 p5.js란 라이브러리의 사용법을 익히기고 그것을 적용해보았다. p5.js란? processing을 기반으로 만들어진 라이브러리로서 dom을 조작하는 것이 아닌 canvas를 생성하고 그 위에서 사용자가 원하는 것들을 그려낸다. setup 함수에서는 사용자가 원하는 canvas를 생성하고 기타 게임시 시작되기 전에 해야할 일들을 처리할 수 있다. draw에서는 게임이 진행되면서 그려줘야 할 것들을 여기서 처리한다. 내부적으로 loop이 돌고있으며 noloop메소드를 setup에 추가하면 loop이 돌지 않고 redraw라는 메소드를 호출해주면 draw가 내부적으로 실행된다. 테트리스로직에서 board 데이터와 block 데이터가 오면 그것들의 좌표를 이용해서 draw_block, draw_board와 같은 메소드들을 만들어 각각을 그려주는 부분을 만들고 그것을 draw 메소드에서 실행시켜서 화면에 그려지도록 하였다. 이렇게 canvas로 그려내니 dom을 조작하는 것도 없어지고, css가 깨져서 여러번 수정해야 할 일도 줄어들어 프로토타입 수준의 게임을 만드는 것이 빨라졌다. 그리고 뷰와 로직이 분리되어있어서 dom element를 생성하는 방식에서 canvas에 그리는 방식으로 바꾸는 것이 수월하였다. 첫번째 완성 ( 오프라인 1인용 테트리스 ) 나의 목적은 멀티플레이 테트리스를 만들기여서 이 다음으로 nodejs 공부에 들어갔다. 물론 자바스크립트와 마찬가지로 nodejs는 전혀 사용해본적이 없었다. nodejs 강의 듣기 이것도 마찬가지로 생활코딩의 강의를 참고하였다. 이전에 서버쪽 프로그래밍을 해본적이 없어서 비교할 대상이 없었지만 기본 철학을 익히고 사용 방법만 익힌 후 내가 하고자하는 것에 필요한 부분만 개념을 익혀서 사용하기로 하였다. 자바스크립트는 원래 웹 브라우저에서만 지원하는 프로그래밍 언어였다. 하지만 구글에서 크롬 웹 브라우저를 발표하면서 브라우저의 성능을 높이기 위해 V8엔진을 만들고 그것을 오픈소스로 공개하였다. V8이 공개되면서 자바스크립트가 웹 브라우저 뿐만아니라 V8엔진이 존재하는 다른 시스템에서도 돌아갈 수 있게 되었고 non-blocking I/O와 event-driven, V8엔진을 조합하여 nodejs라는 기술을 만들어 내었다. 따라서 서버측에서도(웹 브라우저가 없는 환경에서도) 자바스크립트로 서버사이드 프로그램을 만들 수 있게 된 것이다. nodejs를 사용한 작은 프로그램을 분석 해 보기 나는 nodejs의 기본 구조 및 스타일을 알지 못했다. 따라서 nodejs로 작성된 다른 프로그램을 분석 하면서 기본 스타일과 사용법을 익혔고 그것을 내 테트리스 게임에 적용하였다. mutiplay flappy bird readme.md 파일을 읽어보면 nodejs, socket.io, p5.js를 사용하였다고 하였다. 그리고 코드를 살펴보니 socket 관련 코드들이 있었고 이것을 익힐 필요가 있다고 생각하여 socket.io을 먼저 분석해보고 소스 분석에 들어갔었다. websocket과 socket.io 관련 글 웹이 처음 나왔을 때는 사용자와의 상호작용이 큰 부분이 아니었지만 웹 기술이 발전 해 가면서 상호작용에 대한 비중이 커졌고 수요도 많아져서 웹 브라우저와 웹 서버사이에 더 자유로운 양방향 메세지 송수신 방식이 필요했고 그래서 HTML5의 표준의 일부로 websocket의 일부가 등장 했다고 한다. 하지만 websocket을 이용하기엔 복잡하고 까다로웠다 그래서 나온것이 socket.io이며 이것은 자바스크립트를 이용해여 브라우저의 종류에 관계없이 실시간 웹을 구현할 수 있도록 한 기술이다. 개발자가 socket.io에 있는 각 기술들을 이해 못해도 이에 관계없이 사용 가능하다 ( 캡슐화 짱! ) Flappy bird 코드 분석 server.js 에서는 socket.on을 통해 클라이언트에서 들어온 이벤트들을 처리하였다. user가 새로 들어오거나, user가 화면이나 버튼을 클릭하거나, disconnect되었을 때에 그에 맞는 데이터가 socket을 통해 들어오고 그것을 서버쪽 로직에서 처리한다. server.js에서는 gameState객체에서 게임의 전체적인 데이터 처리와 로직 처리를 한다. 게임 화면을 초기화하고 mainloop을 통해서 플레이어의 객체를 돌며 플레이어를 움직이게 하고 유저의 in &amp; out을 처리한다. 클라이언트에는 sketch.js가 존재한다. 여기서는 p5가 적용되어있으며 서버에서 온 데이터(state, position)를 바탕으로 화면을 그려낸다. 이렇게 분석하고 나니 큰 흐름은 nodejs 서버가 돌아가면서 socket으로 클라이언트와 서버가 데이터를 일정한 주기 또는 이벤트에 따라 주고 받고 그것을 모든 클라이언트가 공유하도록 server가 sync를 맞추는 느낌이었다. 이것을 나의 테트리스 게임에 적용시켜 1인용 온라인 게임으로 먼저 만들어 보았다. 기본 게임 로직을 서버로 옮긴다. 클라이언트는 첫 접속시 서버와 socket으로 메세지를 주고 받으며 연결에 필요한 데이터를 주고 받고 연결을 완료시킨다. 아래 그림은agar.io 소스에서 따온 부분이다. flappy bird이외에 이 소스도 분석해서 데이터를 어떻게하면 더 효율적으로 주고 받을지 분석하였다. 서버에서는 게임이 시작하면 메인 루프가 0.4초마다 한번씩돌아간다. 로직과 뷰가 주고받던 데이터가 gameboard와 block이었고, 로직에서 게임의 상태, hold block next block, score등을 가지고 있었기 때문에 그 데이터들을 gameState라는 객체에 담에서 클라이언트로 전송하였다. 클라이언트는 해당 데이터를 받아서 draw_holdblock, draw_nextblock등 각각에 맞는 메소드에 데이터를 보내주고 draw 함수에 의해 이 모든 것들이 화면에 그려진다. 또한 클라이언트는 key event가 발생하면 그 정보를 서버로 전송하고 움직임을 받아서 해당 블록을 움직이는 로직이 실행되도록 하였다. nodejs에서는 require과 module.export를 통해서 모듈 패턴을 구현할 수 있었다. 그러나 이것을 nodejs가 아닌 클라이언트 환경에서 실행시키기 위해서는 이것을 브라우저에서 돌리기위한 작업이 필요하였다. 이 작업을 도와주는 툴에는 browserify와 webpack이 있다. 이 둘중 browserify를 선택하였다. 그 이유는 webpack을 사용하기엔 내 게임이 너무 작았고 그에비해 webpack의 기능은 너무 많고 복잡했다. browserify는 내 게임과 같은 작은 서비스에서 사용하기 적당했다. browserify를 하니 p5가 작동하지 않았다. p5 github의 issue에서 보니 나와 같은 오류가 발생한 사람들이 있었고 browserify후 동작하게 하려면 전역 객체인 p5를 통해 새로운 p5 객체 (new p5 )를 만들어 주면 해결 된다는 글이 있어서 그렇게 해결하였다. 두개의 소스를 분석해서 nodejs가 클라이언트와 데이터를 주고 받으려면 어떻게 해야하는지, nodejs의 스타일은 어떠한지 등을 분석해보고 그것을 내 게임에 적용시켜 보았다. 이제 다른 사람의 소스를 읽고 구조를 파악하고 나에게 맞게 포팅하는 작업이 어떤 것인지 감이 왔다. 1인용 온라인 게임을 다인용 온라인 게임으로 만들어 보기 이제 멀티플레이를 위해서 각 클라이언트는 자신 이외에 다른 클라이언트들의 게임 상황을 똑같이 그려주는 일을 하고자 했다. 그러나 막막했다. 각 클라이언트가 다른 클라이언트의 상태를 계속 동기화 하기 위해서는 어떤 클라이언트가 이벤트를 발생시킬 때 마다 그 내용을 전달받아서 그려줘야 했다. 기존에는 board와 block등등 로직과 관련된 데이터들을 통째로 클라이언트와 주고 받았기때문에 이벤트가 발생할 때 마다 그것을 다른 클라이언트들 전부에게 보내준다는 것은 말도 안돼게 비효율적인 일이었다. 엄청난 트레픽이 발생하겠다는 생각이 들었다. 그래서 다른 것들을 만들기 위해 다른 소스를 분석하다가 OT라는 기술이 있다는 것을 알아내었다. OT는 operation transformation이라는 말의 줄임말로, 핵심 내용은 한 클라이언트가 이벤트를 발생시키면 그것의 ‘변경사항’만을 어떤 객체의 형태로 만들고 그것을 다른 클라이언트에 전달하여 그 이벤트와 같은 행동을 하는 것이다. 그리고 서버는 각 클라이언트가 만들어낸 해석에 불일치가 발생하는지 확인한다. 즉 테트리스에서 생각 해 보자면 어떤 플레이어가 블록을 움직이거나 회전시키면 그 움직임을 action이라는 객체에 담아서 서버로 전송한다. 그러면 그 내용을 다른 클라이언트가 받아서 각 클라이언트가 이벤트를 발생시킨 클라이언트 객체에서 같은 일을 하게 함으로써 각 클라이언트는 다른 클라이언트의 상태를 계속해서 동기화 하는 것이다. 이것을 하려면 서버에 있던 로직을 클라이언트에도 옮기고, 각 클라이언트에서 이벤트가 발생하면, 서버는 그것을 다른 클라이언트에 전달하고, 그 이벤트를 서버 자체에서 해당 클라이언트 객체에 적용시켜서 그 이벤트가 타당한지 적용시켜봐야 했다. 따라서 클라이언트에서도 로직을 가지고 key event나 loop가 돌 때 마다 해당 데이터를 json 형식의 객체로 만들어서 서버에 보내주었고 모든 클라이언트가 다른 클라이언트의 화면을 공유하게 만들었다. 그런데 문제점이 생겼다. 4명 이상의 사람이 들어오게 되면 화면이 오른쪽으로 넘어가버려서 게임 플레이를 진행하기 힘들었고, 사람이 무한히 많아지면 한 게임에 대해 너무 많은 데이터가 오고가며 트레픽이 증가하였다. 따라서 socket의 channel을 room 처럼 생각하여 room manager 구조를 구현하였다. 클라이언트가 접속하면 room mananger는 room을 배정 해 주고, 클라이언트가 4명이 모이면 game start 버튼을 활성화 시킨다. 클라이언트중 한명에 game start 버튼을 누르면 모두가 동시에 game이 시작된다. 멀티플레이 대기화면 플레이 화면 소스코드 배운점 javascript와 nodejs에 대한 이해도가 높아졌고 객체화 모듈화 이벤트화를 적용하려고 노력하였으며 네트워크에서 데이터 교환시 어떤 방식이 효율적인지 배울 수 있었으며 계속 해서 개선시키다보니 리펙토링 할 부분이 계속 보여서 내 코드를 개선해 나가는 것을 배웠다. 다른 사람의 소스를 읽고 내가 필요한 부분만 추출해서 내 서비스에 적용시키는 것을 배웠다. 다른 사람의 소스의 크기가 크더라도 분석이 가능해졌다. 이 모든 것들이 한번에 척척척 한 것이 아닌, 어느 부분이 문제가 있었고, 그 부분을 해결하려면 어떻게 해야하고, 그 해결하는 과정을 작은 게임으로 나누어서 진행하는 것을 배웠다. 어떻게든 찾으면 찾아진다.","link":"/2017/12/01/study-js-nodejs-by-opensource-part1/"},{"title":"Spring의 기본 개념 잡아보기","text":"Spring overview특징 IOC (Inversion Of Control) DI (Dependency Injection) AOP (Aspect-Oriented Programming) PSA (Portable Service Abstraction) IOC (Inversion Of Control) 직역하면 제어권의 역전으로 해석할 수 있다. 보통 어떤 객체(A)가 다른 객체(B)를 사용하고 있다면 A는 B에 dependency가 있다 라고 얘기하며, A 객체 내부에서 B객체를 생성하여(new) 사용할 수 있다. 1234@Controllerclass OwnerController { private val ownerRepository = ownerRepository()} 하지만 Spring은 IOC 특성을 가진다. 즉 Control(dependency를 생성)의 주체가 A class가 아닌 A class 외부이다. 123@Controllerclass OwnerController(private lateinit var ownerRepository: OwnerRepository) {} OwnerRepository를 외부에서 어떤 타이밍에 생성되어 들어오는지는 모르지만 OwnerController는 그걸 신경쓰지 않고 받아서 쓸 뿐이다. 이런식으로 코드를 작성하면 OwnerController와 OwnerRepository간의 dependency가 줄어들기 때문에 테스트 코드를 짜기에도 용이하고, repository를 바꾸거나 controller를 바꾸기도 용이한, 유연한 코드를 짤 수 있겠다. 이 내용만 보면 Inversion of dependency control이라고 생각할 수 있지만 dependency 외에 다른것도 inversion 되어있을 수 있다고 한다. 가령 Servlet을 예로 들면, 어떤 Servlet은 Servlet Container에 속해있으며, Container가 생성 하고, 클라이언트에서 요청이 올 때 실행되므로, Servlet 자신이 제어권을 쥐고 있는 것이 아닌 Container가 쥐고 있으며 이 경우에도 IOC 개념이 사용된다. IOC 컨테이너 Spring framework는 IOC용 Container를 제공 해 준다. Container의 핵심 인터페이스는 Application Context(Bean Factory)이다. 하지만 Application Context는 직접 사용할 일은 없다. Application Context는 단지 뒤에 숨어서 사용자가 만든 IOC class를 Spring에서 동작할 수 있도록 해 준다. 예를 들면 위에서 생성한 OwnerController라는 class는 @Controller라는 Annotation을 달고 있고 Application Context는 Annotation을 보고 인스턴스를 생성 해 준다. 그와 동시에 OwnerController의 parameter인 OwnerRepository 또한 생성하여 생성자에 넣어준다. 정리를 해보자. Container 내부에 생성된 객체들을 Bean이라고 한다. Container는 이 Bean들의 dependency를 관리해준다. 오로지 Bean만 관리한다. Bean Bean은 Spring IOC 컨테이너가 관리하는 객체이다. 보통 class에 @Controller, @Service, @Repository과 같은 Annotation이 붙어있으면 Bean이다. Annotation은 사용자가 붙이는 것이며, 이 객체들간의 dependency를 Container에서 관리해줘라 하는 표시와 같다. Intellij 기준 class 옆에 어떤 표시가 있으면 Bean으로 등록이 된 것이다. 오로지 Bean으로 등록된 객체만 dependency를 관리 해 준다. 어떻게 등록하지? Component Scanning1234567891011package com.example.demoimport org.springframework.boot.autoconfigure.SpringBootApplicationimport org.springframework.boot.runApplication@SpringBootApplicationclass DemoApplicationfun main(args: Array&lt;String&gt;) { runApplication&lt;DemoApplication&gt;(*args)} 보통 Spring project를 생성하면 위와 같이 main 메소드가 있는 Application file이 존재한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {… /** * Base packages to scan for annotated components. Use {@link #scanBasePackageClasses} * for a type-safe alternative to String-based package names. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; this setting is an alias for * {@link ComponentScan @ComponentScan} only. It has no effect on {@code @Entity} * scanning or Spring Data {@link Repository} scanning. For those you should add * {@link org.springframework.boot.autoconfigure.domain.EntityScan @EntityScan} and * {@code @Enable…Repositories} Annotations. * @return base packages to scan * @since 1.3.0 */ @AliasFor(Annotation = ComponentScan.class, attribute = “basePackages”) String[] scanBasePackages() default {}; /** * Type-safe alternative to {@link #scanBasePackages} for specifying the packages to * scan for annotated components. The package of each class specified will be scanned. * &lt;p&gt; * Consider creating a special no-op marker class or interface in each package that * serves no purpose other than being referenced by this attribute. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; this setting is an alias for * {@link ComponentScan @ComponentScan} only. It has no effect on {@code @Entity} * scanning or Spring Data {@link Repository} scanning. For those you should add * {@link org.springframework.boot.autoconfigure.domain.EntityScan @EntityScan} and * {@code @Enable…Repositories} Annotations. * @return base packages to scan * @since 1.3.0 */ @AliasFor(Annotation = ComponentScan.class, attribute = “basePackageClasses”) Class&lt;?&gt;[] scanBasePackageClasses() default {}; 위의 코드와 같이 SpringBootApplication 이라는 Annotation의 구현체를 보면 scanBasePackages, scanBasePackageClasses라는 메소드가 존재함을 볼 수 있다. 즉, Spring에서는 존재하는 모든 package 내의 모든 class에 대해서 component Annotation이 붙어있는 class들을 모두 찾아서 자동으로 Spring framework에 Bean으로 등록한다. @Controller라는 Annotation도 내부 구현을 뜯어보면 @Component라는 Annotation이 붙어있으며, Spring 에서는 이것을 보고 Bean으로 등록하게 된다. 12345@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller { … } 즉 사용자는 Spring의 Component라는 것을 알려줄 수 있는 Annotation을 잘 붙여주면 된다. @Controller @Repository @Service DI (Dependency Injection) Spring에서는 @Autowired, @Inject를 붙여서 DI를 사용할 수 있다. 하지만, 코드상에는 DI와 관련된 Annotaion은 찾아볼 수 없다. 그렇다면 어떻게 DI를 사용할까? ▶ Dependency Injection 조건Spring에서는 @Autowired, @Inject가 없더라도, 아래와 같은 조건을 만족한다면 해당 dependency를 해당 Bean에 Inject 해 준다. 어떤 Bean이 존재하며 그 Bean에 생성자가 오직 하나만 존재하며 그 생성자의 Parameter로 받는 타입의 Bean이 존재 ▶ Bean이 아닌 객체들은 어떻게 Container로 부터 의존성을 주입받을까?@Autowired, @Injection을 생성자, 필드, Setter에 붙여준다. 생성자보통 생성자에서 Inject를 받으며, 테스트 코드를 짤때도 dependency를 mocking하기 용이하다. 필드필드에 붙여줄 수 있지만, test code 작성시 mocking하여 넣어주기가 매우 힘들기 때문에 지양되는 방법이다. SetterSetter 또한 필드와 같은 이유로 지양되는 방법이기는 하나, 필요시에는 사용되며 다음과 같은 기준들로 Annotation을 붙여준다. Setter가 있다는 것은 어떤 dependency를 setter를 통해 변경시키고 싶다는 의미로 볼 수 있다. 따라서 constructor 보다 Setter에 Annotation을 붙여 DI를 해주는 것이 자연스럽지 않는가 생각한다. 만약 Setter가 없고, 생성자나 필드가 존재한다면 Setter를 만들기보다는 그쪽에 Annotation을 두는것이 자연스럽다. 또한 setter를 굳이 만들어주는 것은, 바뀌지 않아야할 dependency를 바뀔 수 도 있도록 하는 것 이므로 굳이 Setter를 만드는 것은 좋지 않다. AOP (Aspect-Oriented Programming) AOP란 쉽게 표현하면 흩어진 코드를 한곳으로 모으는 코딩 기법이다. 예제를 살펴보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 흩어진 AAAA 와 BBBBclass A { fun a () { AAAA 오늘은 7월 4일 미국 독립 기념일이래요. BBBB } fun b () { AAAA 저는 아침에 운동을 다녀와서 밥먹고 빨래를 했습니다. BBBB }}class B { fun c() { AAAA 점심은 이거 찍느라 못먹었는데 저녁엔 제육볶음을 먹고 싶네요. BBBB }}// 모아 놓은 AAAA 와 BBBBclass A { fun a () { 오늘은 7월 4일 미국 독립 기념일이래요. } fun b () { 저는 아침에 운동을 다녀와서 밥먹고 빨래를 했습니다. }}class B { fun c() { 점심은 이거 찍느라 못먹었는데 저녁엔 제육볶음을 먹고 싶네요. }}class AAAABBBB { fun aaaabbb(JoinPoint point) { AAAA point.execute() BBBB }} 위의 주석에 적혀있는 흩어진 AAAA 와 BBBB 코드를 살펴보면 AAAA라는 기능과 BBBB라는 기능이 여러 메소드마다 반복적으로 실행되고 있다. 이러한 흩어진 코드를 모아 놓은 AAAA 와 BBBB와 같이 한곳으로 모아서 처리하는 방식을 AOP라고 할 수 있겠다. 이렇게 구현하는 기법은 크게 두가지가 있다 Bytecode를 조작한다. class A, B가 컴파일된 bytecode에 AAAA, BBBB를 삽입한다. Proxy 패턴 A라는 class를 상속을 받아 AProxy라는 class를 만든다. AProxy class는 a method를 override 해서 A의 a method를 실행하기 전에 AAAA를 실행시키고 A의 a method를 실행시키고 BBBB를 실행시키도록 한다. Spring에서는 Proxy 패턴으로 AOP를 구현하며 framework 내부에서 자동으로 코드를 생성 해 준다. AOP 적용 예제 위에 설명한 것과 비슷한 동작을 필요로 하는것이 보통 logging 이다. Logging 관련 Annotation이 붙어있는 method만 실행시 log를 남기는 예제 코드를 작성 해 보자. Annotation을 만든다. 12345// 이 Annotation은 function에 붙여야 동작한다.@Target(AnnotationTarget.FUNCTION)// 이 Annotation은 Runtime에만 유지된다.@Retention(AnnotationRetention.RUNTIME)Annotation class LogExecutionTime {} 사용할 메소드에 Annotation을 붙여준다. 123456789@Controllerclass HtmlController { @LogExecutionTime @GetMapping(“/“) fun blog(model: Model): String { model[“title”] = “Blog” return “Blog” }} Aspect 만들기 Annotation은 주석과도 같은 것이다. 실제 기능은 없고, 저 Annotation과 mapping되는 Aspect를 만들어 줘야 한다. spring에서 Annotation과 aspect를 연결하려면 aspect가 bean이어야 한다. 123456789101112@Component@EnableAspectJAutoProxyclass LogAspect { @Around(“@Annotation(LogExecutionTime)”) fun logExecutionTime(joinPoint: ProceedingJoinPoint): Any? { val before = System.currentTimeMillis() val result = joinPoint.proceed() val after = System.currentTimeMillis() println(after - before) return result }} 위의 코드와 같이 jointPoint라는 작업이 수행 되기 전 후에 before, after 라는 작업을 수행하도록 하며, Annotation만 붙이면 모든 메소드에서 저러한 작업을 가능하게 해 주는 것이 AOP 개념과 관련된 일을 한다고 보면 되겠다. Before -&gt; 원래 task -&gt; after 순서로 작업이 수행된다. @Around(“@Annotation(LogExecutionTime)”) 부분에서 왜 @Around의 인자값으로 String이 들어가는지 의문이 들 수 있는데, String으로 어떤 메소드가 실행 될 것인지 패턴을 정의해 줄 수 있다. 예를 들면 execution(* set*(..)) 이렇게 set으로 시작하는 method에서만 실행 할 수도 있고, execution(* com.xyz.service..*.*(..)) 이렇게 service 패키지와 하위 모든 메소드들에서 실행 시킬 수 있다. 이런식으로 Annotation과 Aspect를 만들고 나면 나머지 작업들은 spring에서 magically 처리 해준다. PSA (Portable Service Abstraction) 쉬운 말로 잘 만든 인터페이스라고 얘기 할 수 있다. 예시를 들어 설명 해 보자. 나의 코드 — ( 확장성이 좋지 못한 코드 or 특정 기술에 특화되어 있는 코드)오른쪽에 코드와 나의코드가 직접적인 연결이 있다면, 코드가 바뀌거나, 기술이 바뀔때 마다 나의 코드의 영향을 주기 때문에 계속해서 수정을 해야한다. 나의 코드 — PSA (Interface) — ( 확장성이 좋지 못한 코드 or 특정 기술에 특화되어 있는 코드 )인터페이스가 중간에 있다면, 확장성이 좋지 못한 코드 or 특정 기술에 특화되어 있는 코드와 내 코드와 직접적인 연관이 없고 인터페이스만 사용하면 되기 때문에 어떤 변경이 있더라도 내 코드에는 영향이 없어진다. 123456789@Controllerclass HtmlController { @LogExecutionTime @GetMapping(“/“) fun blog(model: Model): String { model[“title”] = “Blog” return “Blog” }} 위와 같은 코드를 보자. @Controller나 @GetMapping은 Servlet과 전혀 상관이 없이 만들어졌다. 저 Annotation을 통해서 해당 기능을 실행하는 주체는 Servlet이 될 수도 있고, netty가 될 수 있다. 우리는 어떤 기술이 뒤에서 사용되고 있는지는 전혀 알 필요 없이 단지 Spring이 제공하는 interface들만 잘 알고 적절하게 사용하면 된다. ▶ PSA - @Transactional@Transactional는 위에서 만든 LogExecutionTime Annotation과 같이 aop 이다. 그러므로 당연히 Transactional 기능을 처리하는 TransactionalAspect가 존재한다. 이 Aspect에서는 기술에 독립적인 PlatformTransactionManager라는 인터 페이스를 사용하여 구현 해 두었다. Platform Transaction Manager는 JpaTransacionManager, DatasourceTransactionManager, HibernateTransactionManager 와 같은 구현체 들이 존재하지만 Transactional Aspect의 코드는 바뀌지가 않는다. 단지 PSA를 쓰고 있기 때문에! Spring에서는 자동으로 JpaTransacionManager를 bean으로 등록 하며, Transactional Aspect는 이를 injection 받아서 해당 기능을 수행하게 될 것이다. ▶ PSA - @Cacheable | @CacheEvict | …이 Annotation이 붙으면 캐쉬 관련 설정이 가능 해 진다. @Transactional과 동일하게, Cache 관련 Annotation도 Aspect를 가지며, 그 Aspect에서는 CacheManager라는 PSA를 사용하게 된다. CacheManager는 JCacheManager, ConcurrentMapCacheManager 등등의 구현체가 있지만 @Transactional과 동일하게 Spring에서 자동으로 injection을 해 줄 뿐이고, 단지 Aspect에서는 CacheManager라는 PSA(interface)를 가져다 쓸 뿐이다! ▶ PSA - 웹 MVC웹 MVC는 @Controller와 @GetMapping Annotation을 이용하여 구현된다. 123456789@Controllerclass HtmlController { @LogExecutionTime @GetMapping(“/“) fun blog(model: Model): String { model[“title”] = “Blog” return “Blog” }} 이 코드 (@Controller, @GetMapping)은 내부적으로 Servlet을 쓰는지, Reactive를 사용하는지 전혀 알수가 없다. 단지 저 Annotation들이 구현하고 있는 Aspect는 웹 관련 PSA를 사용하여 해당 기능을 구현할 뿐이고, 우리는 그것을 신경쓸 필요가 없어졌다. Spring의 전반적으로 중요한 요소들을 정리했다. 이걸 보고 바로 실무에 적용할 수는 없겠지만, 적어도 이런 개념이 있다면 Spring의 수 많은 기능중 내가 필요한 것들을 잘 찾고 이해하며 쓸 수 있을 듯 하다.","link":"/2020/04/09/spring-overview/"},{"title":"오픈소스로 js, nodejs 익히기 part2","text":"왜 길건너친구들인가? 그 당시에 길건너 친구들이라는 게임을 하면서 수 많은 캐릭터들을 모으는것이 재미있었다. 약간의 컨트롤로 큰 재미를 얻을 수 있었다. 테트리스를 만들어보니 아 오픈소스를 찾고 분석하고 나에게 맞게 개선시키면 어떤 게임이든 쉽게 만들 수 있겠다 라는 자신감이 생겼다. 기존의 길건너 친구들은 혼자서 하는 것이었다면 나는 서버를 붙여서 여러 사람이 함께 플레이하는 버전을 만들어 보고 싶었다. ( 이제는 길건너 친구들에 멀티플레이 모드가 생겼다!ㅠㅠ ) Step1 지금까지 나와있는 오픈소스 관련 프로그램과 라이브러리를 구글 검색하고 정리하기 crossy road로 검색한 결과 유니티와 자바스크립트로 만들어진 길건너 친구들 crossy로 검색하니까 검색 결과도 많지 않고, 내가 이해하기에는 너무 큰 소스들만 나왔다. 그래서 구글 검색을 다시 진행해본 결과 crossy road는 fogger라는 고전 게임에서 파생된 게임이라는 것을 알게되었다. Frogger로 검색한 결과 Frogger Arcade Game Frogger Arcade Game의 제일 초기버전 Frogger Arcade Game Improved 이 코드가 주석도 가장 많고, 가장 내가 이해하기 편했다. 여러개의 캐릭터 선택이 가능하다. 캐릭터가 타일 단위로 움직여서 crossy road와 동작이 비슷하다. Frogger Arcade Game less Improved 두번째 버전과 비슷한데, 캐릭터가 타일 단위로 움직이지 않는다. Supermario - made by javascript and phaser 그나마 가장 crossy road와 비슷한 느낌이다. 하지만 phaser라는 게임 엔진을 익혀야 하고, UI를 따와서 쓰기엔 조금 조잡했다. Frogger Arcade with variable character version 게임 시작시 캐릭터를 골라서 시작할 수 있다. 그러나 stage가 넘어가도 다른 캐릭터들이 사라지지 않는다. 캐릭터의 이동이 이상하다. 이렇게 비교 검색해본 결과 내가 이해하기 편하고, 개선시킬 수 있을 것 같은 코드는 Frogger Arcade Game Improved 이 코드였다. Step2 선택한 오픈소스 분석오픈소스를 이해하고 나아가서 개선시키기 위해선 일단 그 오픈소스의 구조가 어떻게 되어있는지 파악하는 일이 필요했다. 그래서 해당 소스를 실행시켜보고 어떻게 돌아가는지 조금 추적해본 후에 로직과 뷰 부분을 분리해서 내부 로직부터 메소드 하나하나 분석해보기 시작했다. 이 소스에서는 app.js, engine.js, resouce.js로 나뉘어져 있었다. app.js에서는 player 객체 enemy객체 popup객체로 나뉘어있었다. enemy객체 initialize 메소드 게임이 진행중 일 때 player 레벨에 따라 speed를 정한다. x , y좌표를 정해서 위 사진처럼 어느 라인에서 벌레들이 나올지 결정한다. update 메소드 벌레들이 화면 끝으로 이동하면 다시 처음 위치로 보낸다. 객체를 재 생성하는 것이 아니고 처음부터 3개를 생성 해 두고 위치를 초기화하는 방식으로 한다. render 메소드 해당 벌레의 이미지를 x,y 값에 따라 그 위치에 그려주기위한 것이다. 이런식으로 각 객체와 engine.js, resource.js를 분석하였고 전체적인 정보 처리 과정을 파악하였다. Step3 분석한 오픈소스에서 개선할 부분 찾기 맨 처음 게임 흐름을 봤을 때 브라우저의 frame rate에 따라 계속해서 조건을 체크하고 상태를 조정하는 것이 나에게는 비효율적이고 왜 이렇게했지? 라는 생각이 들었다. 그런데 벌레들이 계속해서 앞으로 움직이기 위해서, 또는 나중에 서버를 연결했을 때 서버의 응답을 받아서 체크하기 위해서는 어떤 loop을 돌아야 한다는 판단이 들었다. 그리고 게임 개발 관련해서 구글링을 했을 때도 대부분은 loop 돌면서 상태체크 -&gt; 로직 수행 -&gt; 데이터를 기반으로 랜더링 의 과정을 거친다고 한다. app.js에서 player, enemy, popup 객체가 한 파일에 작성되어있었고, 전역객체로 선언되어있었다. 각자의 역할에 맞게 player.js, enemy.js, popup.js 파일을 생성하고 각 객체를 모듈화 시켰다. 그리고 app.js에 game 전체를 관리하는 개념으로 FroggerGame이라는 객체를 만들고 각 모듈을 가져와서 객체화 시켜서 사용하게 하였다. rendering은 전역 객체로 선언된 player, enemy, popup 객체의 데이터를 가져와서 실행하는 방식이었다. 전역 변수, 전역 객체의 사용은 모든 프로그래밍 분야에서 꼭 필요한 것이 아니라면 권장되지 않는다. 따라서 랜더링하는 모듈을 DrawFroggerGame.js로 분리하고, 그것을 FroggerGame에서 불러와서, game 관련 데이터를 넘겨주는 방식으로 랜더링을 진행하도록 하였다. 랜더링이 canvas로 진행되고 있었다. 내 입장에서는 canvas를 직접 다루는 것 보다는 p5.js로 다루는 것이 더 편했고 그것을 더 익히고 싶었기 때문에 rendering 방식을 p5.js를 사용하는 것으로 변경하였다. 전역 변수를 권장하지 않는 이유 변수 범위가 너무 넓어서 이해하기 어렵다. 프로그램 여기 저기서 값을 읽거나 ‘변경’ 가능하므로 사용처를 추적하기 어렵다. 프로그램 내 변수와 함수 등 여러 요소들과 커플링이 심해진다. 동시에 여러 쓰레드가 값을 변경할 수 있으므로 동기화가 필요하다. 전역변수는 모든 곳에서 사용되므로, 네임 스페이스가 오염된다. 즉 어떤 메소드 내부에서만 잠깐 쓸 변수를 선언했는데, 그것이 전역 변수와 같아서 생기는 문제가 있을 수 있다. 테스팅을 위한 환경을 만들기 어렵기 때문에 테스트가 어려워서 프로그램의 품질을 보장하기 어렵다. Step4 1인용 온라인 게임으로 만들기원래 게임이 1인용 오프라인 게임이었고, 그것을 위해서 말한것을 바탕으로 구조를 모듈화를 통해 개선시키고 뷰를 교체하면서 1인용 오프라인 게임이 자연스럽게 완성되었다. 1인용 온라인 게임을 위한 여러가지 생각을 했다. 클라이언트에서는 서버와 데이터를 소켓으로 주고받기 위한 모듈이 필요하다. - &gt; index.js에서 서버와의 데이터 통신을 전담한다. p5 객체를 생성하고 기본 세팅 ( setup 메소드와 draw메소드 세팅) 및 소켓 연결이 완료되었을 때 게임을 시작시키기위한 모듈이 필요하다. -&gt; main.js에서 p5객체를 만들고, 일정 loop을 돌면서 FroggerGame과 DrawFroggerGame과의 데이터 교환을 전담한다. main.js에서는 KeyEvent가 발생하면 그것을 FroggerGame으로 넘겨서 해당 key에대한 로직을 처리하게 한다. 서버에서는 room 구조를 가진다. 나중에 멀티플레이를 위해서 미리 서버 구조를 이렇게 설정해 둔다. socket.io는 채널을 설정할 수 있는 기능이 있고, 그 채널에 접속한 클라이언트들에게만 메세지를 보낼 수 있는 기능이 있다. roomManager를 두고 client 추가 제거, 같은 채널의 클라이언트에게 message broadcast 기능을 전담한다. 소켓으로 클라언트에서 어떤 움직임에 대한 데이터가 들어오면 그 데이터를 내가 아닌 다른 클라이언트들에게만 움직임 정보를 broadcast하고 다른 클라이언트에서는 자신이 아닌 다른 사람의 동작을 받으면 그 동작 그대로 자기 화면에서 움직이는 방식이다. 테트리스에서 멀티플레이를 구현했던 방법과 유사하다. 정확히 될지 안될지는 모르지만 일단 이 방법으로 동기화한다고 생각하고 일단 구현 해 두었다. Step5 다인용 온라인 게임 만들기위의 과정으로, 서버와 클라이언트가 움직임에 대한 데이터를 주고 받으며 혼자서 게임 플레이가 되도록 만들었다. 하지만 아직 멀티플레이를 구현하기에는 부족했다. 그 이유는 2명의 클라이언트에서 버튼을 1초에 100번씩 연타한다고 생각 해 보자. 이 움직임 데이터가 서버로 몰리고, 서버는 1초에 200개의 요청을 처리해서 각 클라이언트로 전달 해 주어야 한다. 그런데 room의 개수가 만약 1000개라고 하면, 서버는 1초에 20만개의 요청을 처리해야하고 room이 늘어나면 늘어날수록 서버의 부하는 커져만 간다. 따라서 이것을 감당하기 위한 구조가 필요했다. 서버의 안정성을 보장하면서 각 플레이간의 동기화를 위한 구조. 멀티플레이 게임을 위한 이론 - Fast-Paced Multiplayer이 홈페이지에 들어가 보면 동기화를 위한 방법의 단계별로 prediction, reconciliation, interpolation을 소개하고 있다. 그리고 그 방법들을 적용했을 경우의 시뮬레이션을 제공하고 있고, 개발자 도구를 이용해서 이것을 어떻게 구현했는지 소스코드를 살펴볼 수 있다. 나는 이기환님이 이 소스를 분석해 보는 것이 어떠냐고 추천해 주셨고, 그래서 이 소스를 오픈소스 분석했던 것과 같이 어떻게 돌아가는지 파악하고, 메소드 하나하나 분석하며, 홈페이지의 글을 읽어보며 전체적인 정보 처리 과정을 익혔다. 간단하게 이야기 해 보자. 우리는 각 플레이어의 움직임을 조금 더 부드럽게 동기화 하고자 한다. 하지만 각 플레이어의 움직임 데이터는 서버를 거쳐야 하기 때문에 일정시간 지연이 발생할 수 밖에 없다. 물론 로컬 환경에서 서버를 돌리고 게임을 돌린다면 지연이 없겠다. 하지만 만약 우리의 서버가 미국에 있고, 미국 서버까지 가는데 50ms가 걸린다고 생각 해 보자. 만약 우리의 움직임을 받아야 하는 클라이언트가 도쿄에 있다면 100,200,심지어 500ms의 시간이 걸릴 수도 있다. 0.5초 우리에게는 매우 작은시간일 수 있지만 게임을 하는 사람의 입장에서는 게임을 진행할 수 없을 정도로 엄청난 렉이 발생하는 것을 경험할 것이다. 따라서 우리는 여러 방법으로 이 문제를 해결할 방법을 모색 해 볼 것이다. Prediction 가정 플레이어가 두명 있고, 그 플레이어 둘이서 서버를 통해 데이터를 주고 받으며 동기화를 하고, 각 플레이어는 방향키를 움직였을 때 그 방향으로 1칸만을 움직이며, 어떤 동작을 행 하기 전에 서버에 그 동작에 대한 데이터를 보내고, 그게 타당한 움직임임을 확인 받은 후(동기화 한 후) 서버의 응답에 따라 움직인다. 위의 가정과 같은 상황에서 플레이어를 1칸 움직인다고 해보자. 서버까지 데이터가 오기 전까지 우리는 100ms가 걸린다고 가정하면 0.1초동안 플레이어는 아무것도 못하고 기다려야 한다. 하지만 우리는 어떤 방향키를 눌렀을때 그 방향으로 1칸 움직인다는 것은 결정론적인 것이고 예측 가능한 상황이다. 따라서 우리는 서버에 요청을 보냄과 동시에 클라이언트에서 임의적으로 애니매이션을 실행시켜서 ‘서버의 응답에 따른 움직임’ 인 것 처럼 동작하게 해도 아무런 문제가 되지 않는다. 하지만 이와같은 동작도 연속된 2개의 입력이 온다면 문제가 된다. 다음의 그림을 살펴보자. 두번의 입력이 클라이언트에서 발생하였다. 그리고 클라이언트에서는 지연시간 없이 두 입력이 빠르게 처리되어 이미 (12,10)으로 이동 되어 있다. 하지만 서버에서는 1개의 입력만이 처리되었고 아직 2번째 입력이 도달하지 못했다. 즉 서버에서는 1칸만 이동했다는 응답이 오는 것이다. 클라이언트에서는 서버의 응답을 받고, 동기화를 위해 1칸 뒤로 이동하게 된다. 그리고 다시 두번째 입력에 대한 응답이 왔을 때 두번째 입력으로 이동한다. 즉 예측해서 움직였지만 결국 서버와의 동기화 때문에 뒤로 한칸 이동했다가 다시 와야하는 일이 발생하였다. ReconciliationPrediction의 상황을 해결하기 위한 방법이다. 만약 클라이언트가 2개의 입력을 이미 처리했는데 서버에서는 1개의 입력만이 처리되었다고 하자. 클라이언트는 입력이 발생하면 그 입력을 일단 자신이 저장하고 있다. 그리고 서버에서는 클라이언트의 데이터를 처리한 내용과 함께 어떤 입력들이 처리되어서 이 결과가 나왔는지에 대한 배열을 같이 클라이언트로 보내준다. 클라이언트에서는 서버에서 준 배열과 자신이 처리한 입력 배열을 비교하며 이미 처리한 내용인지 아닌지를 판단하고 이미 처리된 입력이면 중복해서 플레이어에 적용하지 않고 동기화 되었다는 체크만 하고 무시 해버린다. 이렇게 함으로써 클라이언트는 움직임이 rollback 되지 않는 부드러운 움직임을 볼 수 있고, 서버와의 동기화도 챙길 수 있다. Interpolation 이 방법은 플레이어가 a에서 b로 이동할 때 한번에 워프하듯 이동하는 것이 아닌, 이동 history가 어떻게 될지를 보간법을 통해 계산하는 방법이다. 내가 만드려는 게임은 연속적인 움직임이 아닌, 타일을 기반으로 한칸 한칸 움직이면 되는 게임이라서 보간법까지는 적용하지 않았다. 이렇게 세 이론을 파악하고 소스코드를 분석해 보니 멀티플레이를 어떻게 구현할 지 감이 왔다. 그리고 그것을 코드로 옮겨냈다. 클라이언트에서는 input이 발생하면 일단 처리하고, 서버로 메세지에 input을 담아서 전송한다. 서버에서는 message들이 들어오는대로 messageList에 담아두었다가 0.3초 또는 더 긴 간격마다 message에 들어있는 input에 대한 처리를 진행한다. 서버에서 input 처리가 끝나면 자신이 처리한 inputList와 해당 플레이어의 최종 이동 위치를 각 클라이언트에 전송한다. 각 클라이언트는 처리된 인풋을 받아서, 이미 처리된 데이터이면(input을 만든 장본인) 동기화 체크만 하고 무시하고, 처리되지 않은 데이터면(input을 만든 플레이어가 아닌 다른 플레이어) input에 따라 똑같이 움직이도록 해서 최종 이동 위치와 비교한다(for 타당성 체크) 다른 플레이어의 움직임을 재현할 때 inputList 데이터를 하나하나 반영시키면서 워프하는 것이 아닌 한칸씩 움직이도록 한다. 이렇게 게임을 진행시키면 클라이언트에서 아무리 많은 데이터가 발생해도 서버에서는 0.3초마다 데이터를 처리하기 때문에 서버가 감당하는 부하가 줄어들고, 각 플레이어의 움직임도 부드럽게 이동하는 것을 어느정도 보장할 수 있다. 아직 원활한 플레이를 위해서는 더 해결해야할 문제가 있지만 개인 프로젝트라서 이정도에서 마무리 지었다. Frogger-game source code 클라이언트가 접속하면 server.js에서 연결요청을 받고 RoomManager에 socket객체를 넘긴다. roomManager에서는 클라이언트를 적절한 room에 배정한다. gameRoom에서는 fase-paced 이론에 따라서 0.3초마다 데이터를 받고 처리해서 다른 플레이어들에게 전송하는 기능을 한다. 이 프로젝트로 배운점 아무리 작은 프로그램이라도 눈에 보이는 것보다 어렵다. 게임 상태를 공유하고 그것을 여러사람이 플레이하려면 단순히 데이터를 전달하는 것이 아니라 서버는 어떤 부하를 견뎌야 하고, 부드러운 움직임을 위해서는 어떤 고려를 해야하는지를 배웠다. 어떤 이론을 이해하고 그 이론을 코드로 표현 해 냈다. 내가 무언가를 만들기 위해서 밟아야할 step을 작은 게임으로 나누었고 그것들을 해결하면서 하나를 완성하였다. 이 프로젝트를 하면서 들었던 생각이, 나는 학교 다닐때 콘솔로만 프로그래밍을 하다보니까 객체화 모듈화 이벤트화 등등의 개념이 크게 와닿지 않았다. 그냥 쭉 이어서 만들어도 돌아갔으니까. 하지만 뷰를 만들어보고 그것을 로직과 연결하는 경험을 하니 어떻게하면 뷰와 로직을 더 분리할지, 로직의 데이터를 뷰에 효과적으로 전달할지 뷰에서 이벤트가 발생하였을 때 이것을 어떻게 로직으로 전달할지 등의 고민을 함에 따라서 위의 개념들이 필요함을 느꼈다. 그리고 서버까지 연결하면서 어떻게하면 서버와의 통신을 효율적으로 할지, 통신하는 부분과 뷰 로직을 어떻게 나눌지를 고민하다보니 그것을 자연스럽게 고민하게 되었다. 모든 이론이 나온 것에는 이유가 있다. 다 개발을 하면서 했던 고민들의 산출물이며, 그것들을 단순히 받아들이기보다는 이런 작은 게임이라도 만들면서 그것을 직접 느껴봐서 좋았다는 느낌이 든다. 그리고 이런 작은 시도들이 나중에 더 큰것을 하게 해줄 것이다.","link":"/2017/12/05/study-js-nodejs-by-opensource-part2/"}],"tags":[{"name":"오픈소스","slug":"오픈소스","link":"/tags/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"flutter plugin","slug":"flutter-plugin","link":"/tags/flutter-plugin/"},{"name":"플러터 플러그인","slug":"플러터-플러그인","link":"/tags/%ED%94%8C%EB%9F%AC%ED%84%B0-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/"},{"name":"flutter packages","slug":"flutter-packages","link":"/tags/flutter-packages/"},{"name":"wifi","slug":"wifi","link":"/tags/wifi/"},{"name":"pub.dev","slug":"pub-dev","link":"/tags/pub-dev/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"tslint","slug":"tslint","link":"/tags/tslint/"},{"name":"typescript-eslint","slug":"typescript-eslint","link":"/tags/typescript-eslint/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"AST","slug":"AST","link":"/tags/AST/"},{"name":"eslint-config","slug":"eslint-config","link":"/tags/eslint-config/"},{"name":"context","slug":"context","link":"/tags/context/"},{"name":"widget","slug":"widget","link":"/tags/widget/"},{"name":"widget tree","slug":"widget-tree","link":"/tags/widget-tree/"},{"name":"element tree","slug":"element-tree","link":"/tags/element-tree/"},{"name":"stateless widget","slug":"stateless-widget","link":"/tags/stateless-widget/"},{"name":"stateful widget","slug":"stateful-widget","link":"/tags/stateful-widget/"},{"name":"inherited widget","slug":"inherited-widget","link":"/tags/inherited-widget/"},{"name":"provider","slug":"provider","link":"/tags/provider/"},{"name":"sentry","slug":"sentry","link":"/tags/sentry/"},{"name":"toy project","slug":"toy-project","link":"/tags/toy-project/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"ios","slug":"ios","link":"/tags/ios/"},{"name":"swift","slug":"swift","link":"/tags/swift/"},{"name":"programming paradigm","slug":"programming-paradigm","link":"/tags/programming-paradigm/"},{"name":"imperative programming","slug":"imperative-programming","link":"/tags/imperative-programming/"},{"name":"declarative programming","slug":"declarative-programming","link":"/tags/declarative-programming/"},{"name":"선언형 프로그래밍","slug":"선언형-프로그래밍","link":"/tags/%EC%84%A0%EC%96%B8%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"명령형 프로그래밍","slug":"명령형-프로그래밍","link":"/tags/%EB%AA%85%EB%A0%B9%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"함수형 프로그래밍","slug":"함수형-프로그래밍","link":"/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"computer science","slug":"computer-science","link":"/tags/computer-science/"},{"name":"cs","slug":"cs","link":"/tags/cs/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"kotlin","slug":"kotlin","link":"/tags/kotlin/"},{"name":"server","slug":"server","link":"/tags/server/"},{"name":"IOC","slug":"IOC","link":"/tags/IOC/"},{"name":"Bean","slug":"Bean","link":"/tags/Bean/"},{"name":"DI","slug":"DI","link":"/tags/DI/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"PSA","slug":"PSA","link":"/tags/PSA/"}],"categories":[{"name":"Software Development","slug":"Software-Development","link":"/categories/Software-Development/"},{"name":"opensource","slug":"Software-Development/opensource","link":"/categories/Software-Development/opensource/"},{"name":"git","slug":"Software-Development/git","link":"/categories/Software-Development/git/"},{"name":"Flutter","slug":"Software-Development/Flutter","link":"/categories/Software-Development/Flutter/"},{"name":"Tools","slug":"Software-Development/Tools","link":"/categories/Software-Development/Tools/"},{"name":"Computer Science","slug":"Software-Development/Computer-Science","link":"/categories/Software-Development/Computer-Science/"},{"name":"nodejs","slug":"Software-Development/nodejs","link":"/categories/Software-Development/nodejs/"},{"name":"Server","slug":"Software-Development/Server","link":"/categories/Software-Development/Server/"}]}